\documentclass{article}

% Packages
\usepackage{fuzz}
\usepackage[margin=1.0in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{language=SQL,
  basicstyle={\small\ttfamily},
  belowskip=3mm,
  breakatwhitespace=true,
  breaklines=true,
  classoffset=0,
  columns=flexible,
  commentstyle=\color{dkgreen},
  framexleftmargin=0.5em,
  frameshape={}{}{}{},
  keywordstyle=\color{blue},
  numbers=none,
  numberstyle=\tiny\color{gray},
  showstringspaces=false,
  stringstyle=\color{mauve},
  tabsize=3,
  xleftmargin =0em
}
\definecolor{delim}{RGB}{20,105,176}
\definecolor{numb}{RGB}{106, 109, 32}
\definecolor{string}{rgb}{0.64,0.08,0.08}

\lstdefinelanguage{json}{
    numbers=none,
    numberstyle=\small,
    frame=none,
    rulecolor=\color{black},
    showspaces=false,
    showtabs=false,
    breaklines=false,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
    breakatwhitespace=true,
    basicstyle=\ttfamily\small,
    upquote=true,
    morestring=[b]",
    stringstyle=\color{string},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}
\usepackage{prooftree}

% Metadata
\title{Final Assignment}
\date{\vspace{-1.0cm}18th June 2024}

% Start
\begin{document}
\maketitle

\section*{Q1}

\subsection*{\small a)}

\textbf{Personal Information}
\newline \newline Assumptions:
\begin{itemize}
    \item I've assumed that the schema doesn't need to support a broad list of genders and therefore it’s stored as an attribute on the $User$ relation rather split into its own.
\end{itemize}

\begin{schema}{User}
	\underline{userId}: UserIdType \\
    emailAddress: EmailAddressType \\
	firstName: NameType \\
	lastName: NameType \\
    dateOfBirth: DateType \\
    gender: GenderType \\
    height: HeightType \\ 
\end{schema}

\begin{zed}
\textcolor{red}{PK}(User) = \{ userId \} \\
\end{zed}

\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Health Status Data}
\newline \newline Assumptions:
\begin{itemize}
  \item I've assumed that eventually we would capture additional attributes tied to the reading e.g location and therefore it made sense to normalise the relation and store readings and metrics separately.
  \item I've also assumed blood pressure should be broken down into systolic and diastolic readings and therefore should be separate attributes.
\end{itemize}

\begin{schema}{HealthReading}
	\underline{readingId}: ReadingIdType \\
    readAt: DateTimeType \\
    userId: UserIdType \\
\end{schema}

\begin{schema}{HealthMetrics}
    \underline{metricsId}: MetricIdType \\
    readingId: ReadingIdType \\
    weight: WeightType \\ 
    glucoseLevel: GlucoseLevelType \\
    systolicBloodPressure: BloodPressureType \\
    diastolicBloodPressure: BloodPressureType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(HealthReading) = \{ readingId \} \\ 
\textcolor{red}{PK}(HealthMetrics) = \{ metricsId \} \\
\newline \\ 
(HealthMetrics, HealthReading) \mapsto \{ readingId \mapsto readingId \} \in \textcolor{red}{FK} \\
(HealthReading, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
\end{zed}
    
\hspace{-0.5cm}\textbf{Diet Data}
\newline \newline Assumptions:
\begin{itemize}
  \item That meals, food and drink is meant to capture diet information at a very high level and there is no need to store a broad defined list of food/drink types/names. 
  \item That calories should only be stored for Food/Drinks with drinks stored by type and glasses consumed and food stored by name and quantity.
\end{itemize}

\begin{schema}{Diet}
    \underline{dietId}: DietId \\
    forDate: DateType \\
    userId: UserIdType \\
\end{schema}

\begin{schema}{Meal}
	\underline{mealId}: MealId \\
    dietId: DietId \\
    mealType: MealType \\
    mealSize: SizeType \\
\end{schema}

\begin{schema}{Food}
	\underline{foodId}: FoodId \\
    dietId: DietId \\
    foodName: FoodNameType \\
    calories: CaloriesType \\
    quantity: \nat_1 \\
\end{schema}

\begin{schema}{Drink}
	\underline{drinkId}: DrinkId \\
    dietId: DietId \\
    drinkType: DrinkType \\
    calories: CaloriesType \\
    glasses: \nat_1 \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(Diet) = \{ dietId \} \\
\textcolor{red}{PK}(Meal) = \{ mealId \} \\
\textcolor{red}{PK}(Food) = \{ foodId \} \\
\textcolor{red}{PK}(Drink) = \{ drinkId \} \\
\newline \\ 
(Diet, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
(Meal, Diet) \mapsto \{ dietId \mapsto dietId \} \in \textcolor{red}{FK} \\
(Food, Diet) \mapsto \{ dietId \mapsto dietId \} \in \textcolor{red}{FK} \\
(Drink, Diet) \mapsto \{ dietId \mapsto dietId \} \in \textcolor{red}{FK} \\
\end{zed}
    
\hspace{-0.5cm}\textbf{Gym Performance Data}

\begin{schema}{Exercise}
	\underline{exerciseId}: ExerciseIdType \\
	exerciseName: ExerciseNameType
\end{schema}

\begin{schema}{Workout}
	\underline{workoutId}: WorkoutIdType \\
    occurredAt: DateTimeType \\
    userId: UserIdType \\
\end{schema}

\begin{schema}{WorkoutSession}
    \underline{sessionId}: SessionIdType \\
    workoutId: WorkoutIdType \\
    exerciseId: ExerciseIdType \\
    weightLevel: WeightLevelType \\
    numberOfSets: \nat_1 \\
    repetitionsPerSet: \nat_1  \\
\end{schema}
\begin{zed}
\textcolor{red}{PK}(Exercise) = \{ exerciseId \} \\
\textcolor{red}{PK}(Workout) = \{ workoutId \} \\
\textcolor{red}{PK}(WorkoutSession) = \{ sessionId \} \\
\newline \\ 
(WorkoutSession, Workout) \mapsto \{ workoutId \mapsto workoutId \} \in \textcolor{red}{FK} \\
(WorkoutSession, Exercise) \mapsto \{ exerciseId \mapsto exerciseId \} \in \textcolor{red}{FK} \\
\end{zed}

\hspace{-0.5cm}\textbf{Movement Data}

\begin{schema}{DailyMovement}
    \underline{dailyMovementId}: DailyMovementId \\
    calories: CaloriesType \\
    distance: DistanceType \\ 
    stairs: \nat \\
    steps: \nat \\
    pace: PaceType \\
    date: DateType \\
    userId: UserIdType \\
\end{schema}

\begin{schema}{HourlyMovement}
    \underline{hourlyMovementId}: HourlyMovementId \\
    calories: CaloriesType \\
    distance: DistanceType \\ 
    stairs: \nat \\
    steps: \nat \\
    pace: PaceType \\
    date: DateType \\
    time: TimeType \\
    userId: UserIdType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(DailyMovement) = \{ dailyMovementId \} \\
\textcolor{red}{PK}(HourlyMovement) = \{ hourlyMovementId \} \\
\newline \\ 
(DailyMovement, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
(HourlyMovement, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
\end{zed}
    
\hspace{-0.5cm}\textbf{Personal Goals}

\begin{schema}{Goal}
	\underline{goalId}: GoalId \\
    userId: UserIdType \\
    startOn: DateTimeType \\
    endAt: DateTimeType \\ 
    description: DescriptionType \\
    objective: ObjectiveType \\
    measurement: MeasurementType \\
    target: TargetType \\ 
\end{schema}

\begin{schema}{GoalOutcome}
	\underline{outcomeId}: OutcomeId \\
    goalId: GoalId \\
    achievedAt: DateTimeType \\
    status: Status \\
\end{schema}

\begin{schema}{GoalMessage}
	\underline{messageId}: MessageId \\
    outcomeId: OutcomeId \\
    subject: SubjectType \\
    message: MessageType \\
\end{schema}

\begin{schema}{GoalEvidence}
	\underline{evidenceId}: EvidenceId \\
    goalId: GoalId \\
    dailyMovementId: DailyMovementId \\
    hourlyMovementId: HourlyMovementId \\
    healthReadingId: HealthReadingId \\
    sessionId: WorkoutSessionIdType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(Goal) = \{ goalId \}  \\
\textcolor{red}{PK}(GoalOutcome) = \{ outcomeId \}  \\
\textcolor{red}{PK}(GoalNotification) = \{ notificationId \}  \\
\textcolor{red}{PK}(GoalEvidence) = \{ evidenceId \}  \\
\newline \\ 
(Goal, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
(GoalOutcome, Goal) \mapsto \{ goalId \mapsto goalId \} \in \textcolor{red}{FK} \\
(GoalMessage, GoalOutcome) \mapsto \{ outcomeId \mapsto outcomeId \} \in \textcolor{red}{FK} \\
(GoalEvidence, Goal) \mapsto \{ goalId \mapsto goalId \} \in \textcolor{red}{FK} \\
(GoalEvidence, DailyMovement) \mapsto \{ dailyMovementId \mapsto dailyMovementId \} \in \textcolor{red}{FK} \\
(GoalEvidence, HourlyMovement) \mapsto \{ hourlyMovementId \mapsto hourlyMovementId \} \in \textcolor{red}{FK} \\
(GoalEvidence, HealthReading) \mapsto \{ healthReadingId \mapsto healthReadingId \} \in \textcolor{red}{FK} \\
(GoalEvidence, WorkoutSession) \mapsto \{ sessionId \mapsto sessionId \} \in \textcolor{red}{FK} \\
\end{zed}

\subsection*{\small b)}

The schema has been designed to be in 3NF but to meet this standard I needed to make sure the schema meets the rules set out for 1NF and 2NF. \\
\newline
I've made sure the schema is in 1NF by flattening each relation removing repeating groups ensuring each attribute in each relation contains only a single value. \\ 
\newline
To meet the rules of 2NF I identified partial dependencies and moved them into their own relations to ensure that every non primary key attribute is fully dependent on any candidate key in the relation. \\
\newline
Finally, to meet 3NF I identified and removed any attributes that were transitively dependent on the primary key moving them into their own relation as well, removing additional redundancy. 

\subsection*{\small c)}

\textbf{\small{C1}}
\begin{zed}
\forall g: Goal @ \lnot (g.endDate < g.startDate) \\
\end{zed}
\textbf{\small{C2}}
\begin{zed}
\forall dm: DailyMovement @ \\
    \t1 d.calories = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.calories \} \\
    \t1 d.distance = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.distance \} \\
    \t1 d.stairs = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.stairs \} \\
    \t1 d.steps = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.steps \} \\
\end{zed}
\textbf{\small{C3}}
\begin{zed}
\forall u: User; d: DateType @ \\
\t1 \#\{ g: Goal | g.userId = u.userId \land g.startsAt \leq d \land g.endsAt > d \} \leq 3
\end{zed}
\textbf{\small{C4}}
\begin{zed}
\forall o: GoalOutcome @ \\
\t1 \exists e: GoalEvidence | e.goalId = o.goalId @ \\
\t2 \{ h: HourlyMovement | e.hourlyMovementId = h.hourlyMovementId \} \neq \emptyset \lor \\
\t2 \{ d: DailyMovement | e.dailyMovementId = d.dailyMovementId \} \neq \emptyset \lor \\
\t2 \{ s: WorkoutSession | e.sessionId = s.sessionId \} \neq \emptyset \\
\t2 \{ r: HealthReading | e.healthReadingId = r.healthReadingId \} \neq \emptyset \lor \\
\end{zed}
\textbf{\small{Additional Constraints}}

\begin{itemize}
  \item It would make sense to introduce a constraint to make sure there is at most 1 entry in the $Diet$ relation for each user for each day, ensuring all $Meal$ / $Food$ / $Drink$ entries are grouped together in a consistent manner.
  \item For goals it would make sense to ensure consistency between the $userId$ referenced for the goal and the evidence tied to the $GoalOutcome$. It would also make sense to ensure the $achievedAt$ is not before or after the goal period captured in the $startOn$ and $endAt$ attirbutes in the $Goal$ relation.
\end{itemize}

\subsection*{\small d)}

I would want to ask various questions to dive deeper into the requirements regarding the type of data we would store. When it comes to attributes like a user’s $height$ or a health reading’s $value$ it would make sense establish the requirements around precision to help optimized the solution a database storage level. There are various like values such as $Gender$, $MetricUnitType$, $DrinkType$ which would be good to get more details to be able to firmly say should they enum style types or have their own relations to new values can be added easier in future. \\
\newline
I'd like to also ask for more detailed examples of how data would be queried. This would help identify important attributes in the relations that would potentially benefit from having an index applied. For example would a regular index on the $GoalOutcome$ $status$ attribute make sense so users could retrieve failed goals easier? Or potentially a clustered index $startsOn$ attribute in the $Goal$ relation to users can query goals that started within a given range efficiently. \\
\newline
I would also ask about the amount of data being stored and estimates for expected reads and writes over a typical period. As it would be good to clarify the required performance and scaling needs when implementing the schema. As we may need to apply techniques such as read replicas, partitions, sharding and potentially denormalization to ensure we meet expectations on performance and scale gracefully.

\pagebreak

\section*{Q2}

For answering these questions I've assumed the presence of the $currentUser$ variable which is of type $User$ that captures the user executing the query. I've also assumed that the $DateType$ type used in the schema has year, month and day variables that are natural numbers. Finally I've assumed that $distance$ in the $DailyMovement$ relation is stored as miles and no converstion is required for the query.

\subsection*{\small a)}

\begin{zed}
\{ d: DailyMovement | \\
    \t1 d.userId = currentUser.userId \land \\
    \t1 d.date.year = 2023 \land d.date.month = 2 \land \\
    \t1 d.distance \geq 1 \land d.pace \in \{ Walked, Ran \} \\
        \t2 @ \lblot day == d.date.day \rblot \}
\end{zed}

\subsection*{\small b)}
\begin{zed}
\{ g: Goal | \\
    \t1 g.userId = currentUser.userId \land \\
    \t1 g.startAt.month \leq 1 \land g.startAt.year \leq 2023 \\
    \t1 g.endOn.month \geq 1 \land g.endOn.year \geq 2023 \} \\
\end{zed}

\subsection*{\small c)}
\begin{zed}
A == Restrict\{userId = currentUser.userId \}(Goal) \\
B == Restrict\{achievedAt.year = 2023 \land status = Success \}(GoalOutcome) \\
C == Project\{achievedAt.year, achievedAt.month, goalId\}(Join(A, B)) \\
D == C\ GroupBy(Count(goalId)\ as\ metPerMonth) \\
E == Project\{year, metPerMonth\}(D) \\
F == E\ GroupBy(Max(metPerMonth)\ as\ maxGoalsMet) \\
G == Project\{month\}(Restrict\{maxGoalsMet = metPerMonth\}(Join(E, F)) \\
\end{zed}

\subsection*{\small d)}
\begin{zed}
A == Restrict\{userId = currentUser.userId\}(DailyMovement) \\
B == Restrict\{date.year = 2023 \}(A) \\
C == Project\{date, calories\}(B) \\
D == C\ GroupBy(Sum(calories)\ as\ dailyTotal) \\ 
E == Project\{date.month, dailyTotal\}(D) \\ 
F == E\ GroupBy(Avg(dailyTotal)\ as\ dailyAverage) \\
\end{zed}

\pagebreak

\section*{Q3}
The SQL provided has been written to be compatible with MySQL v8.0 and would potentially need to be tweaked in circumstances for other relational database options.
\vspace{-0.2cm}
\subsection*{\small a)}
\vspace{-0.3cm}
\begin{lstlisting}[language=sql]
/* User Data */
CREATE Table User (
  userId INT AUTO_INCREMENT PRIMARY KEY,
  emailAddress VARCHAR(100) UNIQUE NOT NULL,
  firstName VARCHAR(50) NOT NULL,
  lastName VARCHAR(50) NOT NULL,
  dateOfBirth DATE NOT NULL,
  gender ENUM('M', 'F', 'O') NOT NULL,
  height DECIMAL(5,2) NOT NULL
);

/* Health Reading */
CREATE TABLE HealthReading (
  readingId INT AUTO_INCREMENT PRIMARY KEY,
  readAt TIMESTAMP NOT NULL,
  userId INT NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(userId)
);

CREATE TABLE HealthMetrics (
  metricsId INT AUTO_INCREMENT PRIMARY KEY,
  readingId INT NOT NULL,
  weight DECIMAL(5, 2) NOT NULL,
  glucoseLevel DECIMAL(5, 2) NOT NULL,
  systolicBloodPressure INT NOT NULL,
  diastolicBloodPressure INT NOT NULL,
  FOREIGN KEY (readingId) REFERENCES HealthReading(readingId)
);

/* Diet Data */
CREATE TABLE Diet (
  dietId INT AUTO_INCREMENT PRIMARY KEY,
  forDate DATE NOT NULL,
  userId INT NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(userId)
);

CREATE TABLE Meal (
  mealId INT AUTO_INCREMENT PRIMARY KEY,
  dietId INT NOT NULL,
  mealType ENUM('Breakfast', 'Lunch', 'Dinner') NOT NULL,
  mealSize ENUM('Light', 'Medium', 'Heavy') NOT NULL,
  FOREIGN KEY (dietId) REFERENCES Diet(dietId)
);

CREATE TABLE Food (
  foodId INT AUTO_INCREMENT PRIMARY KEY,
  dietId INT NOT NULL,
  foodName VARCHAR(255) NOT NULL,
  calories DECIMAL(5, 2) NOT NULL,
  quantity INT NOT NULL,
  FOREIGN KEY (dietId) REFERENCES Diet(dietId)
);

CREATE TABLE Drink (
  drinkId INT AUTO_INCREMENT PRIMARY KEY,
  dietId INT NOT NULL,
  drinkType ENUM('Water', 'Juice', 'Soda') NOT NULL,
  calories DECIMAL(5, 2) NOT NULL,
  glasses INT NOT NULL,
  FOREIGN KEY (dietId) REFERENCES Diet(dietId)
);

/* Gym Performance Data */
CREATE TABLE Exercise (
  exerciseId INT AUTO_INCREMENT PRIMARY KEY,
  exerciseName VARCHAR(50) NOT NULL
);

CREATE Table Workout (
  workoutId INT AUTO_INCREMENT PRIMARY KEY,
  occuredAt DATETIME NOT NULL,
  userId INT NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(userId)
);

CREATE TABLE WorkoutSession (
  sessionId INT AUTO_INCREMENT PRIMARY KEY,
  workoutId INT NOT NULL,
  exerciseId INT NOT NULL,
  weightLevel DECIMAL(5, 2) NOT NULL,
  numberOfSets INT NOT NULL,
  repetitionsPerSet INT NOT NULL,
  FOREIGN KEY (workoutId) REFERENCES Workout(workoutId),
  FOREIGN KEY (exerciseId) REFERENCES Exercise(exerciseId)
);

/* Movement Data */
CREATE TABLE DailyMovement (
  dailyMovementId INT AUTO_INCREMENT PRIMARY KEY,
  calories DECIMAL(5, 2) NOT NULL,
  distance DECIMAL(8, 2) NOT NULL,
  stairs INT NOT NULL,
  steps INT NOT NULL,
  pace ENUM('Walked', 'Ran', 'Jogged') NOT NULL,
  date DATE NOT NULL,
  userId INT NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(userId)
);

CREATE TABLE HourlyMovement (
  hourlyMovementId INT AUTO_INCREMENT PRIMARY KEY,
  calories DECIMAL(5, 2) NOT NULL,
  distance DECIMAL(8, 2) NOT NULL,
  stairs INT NOT NULL,
  steps INT NOT NULL,
  pace ENUM('Walked', 'Ran', 'Jogged') NOT NULL,
  date DATE NOT NULL,
  time TIME NOT NULL,
  userId INT NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(userId)
);

/* Personal Goals */
CREATE TABLE Goal (
  goalId INT AUTO_INCREMENT PRIMARY KEY,
  userId INT NOT NULL,
  startOn DATE NOT NULL,
  endAt DATE NOT NULL,
  description VARCHAR(255) NOT NULL,
  objective ENUM('Weight Loss', 'Toning', 'Ran', 'Walked') NOT NULL,
  measurement ENUM('kg', 'km') NOT NULL,
  target DECIMAL(8, 2) NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(userId)
);

CREATE TABLE GoalOutcome (
  outcomeId INT AUTO_INCREMENT PRIMARY KEY,
  goalId INT NOT NULL,
  achievedAt DATETIME NOT NULL,
  status ENUM('Success', 'Failed') NOT NULL,
  FOREIGN KEY (goalId) REFERENCES Goal(goalId)
);

CREATE TABLE GoalMessage (
  messageId INT AUTO_INCREMENT PRIMARY KEY,
  outcomeId INT NOT NULL,
  subject VARCHAR(50) NOT NULL,
  message TEXT NOT NULL
);

CREATE TABLE GoalEvidence (
  evidenceId INT AUTO_INCREMENT PRIMARY KEY,
  goalId INT NOT NULL,
  dailyMovementId INT,
  hourlyMovementId INT,
  healthReadingId INT,
  workoutSessionId INT,
  FOREIGN KEY (dailyMovementId) REFERENCES DailyMovement(dailyMovementId),
  FOREIGN KEY (hourlyMovementId) REFERENCES HourlyMovement(hourlyMovementId),
  FOREIGN KEY (healthReadingId) REFERENCES HealthReading(readingId),
  FOREIGN KEY (workoutSessionId) REFERENCES WorkoutSession(sessionId)
);
\end{lstlisting}


\pagebreak
\subsection*{\small b)}

\textbf{\small{C1}}
\begin{lstlisting}[language=sql]
ALTER TABLE Goal ADD CONSTRAINT Check_EndsAt CHECK (NOT endsAt < startAt);
\end{lstlisting}
\textbf{\small{C2}}
\begin{lstlisting}[language=sql]
CREATE TRIGGER CheckDailyMovement
BEFORE INSERT ON DailyMovement
REFERENCING NEW ROW AS newrow FOR EACH ROW
BEGIN ATOMIC
    IF ((newrow.calories, newrow.distance, newrow.stairs, newrow.steps) <> (
        SELECT SUM(calories), SUM(distance), SUM(stairs), SUM(steps) 
        FROM HourlyMovement 
        WHERE userId = newrow.userId and pace = newrow.pace and date = newrow.date
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Daily/Hourly figures are not consistent';
    END IF;
END;
\end{lstlisting}
\textbf{\small{C3}}
\begin{lstlisting}[language=sql]
CREATE TRIGGER CheckActiveGoals
BEFORE INSERT ON Goal
REFERENCING NEW ROW AS newrow FOR EACH ROW
BEGIN ATOMIC
    IF ( 
      SELECT 1 + COUNT(*) 
      FROM Goal 
      WHERE newrow.userId = userId and (
        newrow.startAt BETWEEN startAt and endAt or 
        newrow.endAt BETWEEN startAt and endAt
      ) >= 3  
    ) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'User cannot have more than 3 active goals';
    END IF;
END;
\end{lstlisting}
\textbf{\small{C4}}
\begin{lstlisting}[language=sql]
CREATE TRIGGER CheckActiveGoals
BEFORE INSERT ON GoalOutcome
REFERENCING NEW ROW AS newrow FOR EACH ROW
BEGIN ATOMIC
  IF (  
    SELECT COUNT(*) 
    FROM GoalOutcome 
    WHERE 
      goalId = newrow.goalId
      dailyMovementId <> NULL OR 
      hourlyMovementId <> NULL OR 
      sessionId <> NULL OR 
      healthReadingId <> NULL
    >= 1
  ) THEN
      SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Outcome must have one piece of evidence minimum';
  END IF;
END;
\end{lstlisting}

\pagebreak 

\subsection*{\small c)}

\textbf{\small{a.}}
\begin{lstlisting}[language=sql]
SELECT DAY(date) 
FROM DailyMovement 
WHERE 
  userId = :currentUserId AND 
  YEAR(date) = 2023 AND MONTH(date) = 2 AND 
  distance >= 1 AND pace in ('Walked', 'Ran')
\end{lstlisting}
\textbf{\small{b.}}
\begin{lstlisting}[language=sql]
SELECT * 
FROM Goal 
WHERE 
  userId = :currentUserId AND 
  startAt <= '2023-01-01' AND endOn >= '2023-01-31'
\end{lstlisting}
\textbf{\small{c.}}
\begin{lstlisting}[language=sql]
SELECT MONTH(o.achievedAt) FROM Goal g
INNER JOIN GoalOutcome o ON g.goalId = o.goalId 
WHERE YEAR(o.achievedAt) = 2023 AND g.userId = :currentUserId
GROUP BY MONTH(o.achievedAt)
ORDER BY COUNT(g.goalId) DESC
LIMIT 1
\end{lstlisting}
\textbf{\small{d.}}
\begin{lstlisting}[language=sql]
SELECT MONTH(date), AVG(dailyCalories) FROM (
  SELECT date, SUM(calories) as 'dailyCalories'
  FROM DailyMovement 
  WHERE YEAR(date) = 2023 and userId = :currentUserId
  GROUP BY DAY(date)
)
\end{lstlisting}

\pagebreak

\section*{Q4}

\subsection*{\small a)}

Non Relational Design: https://www.mongodb.com/blog/post/building-with-patterns-a-summary

\subsection*{\small b)}

% Query 1 % 
\hspace{0cm}1.
\begin{lstlisting}[language=json]
{
    "query": 100
} 
\end{lstlisting} 
% Query 2 % 
\hspace{0cm}2.
\begin{lstlisting}[language=json]
{                   
    "query": 100
}
\end{lstlisting}
% Query 3 % 
\hspace{0cm}3. 
\begin{lstlisting}[language=json]
{
    "query": 100
}
\end{lstlisting}
% Query 4 % 
\hspace{0cm}4. 
\begin{lstlisting}[language=json]
{
    "query": 100
}
\end{lstlisting}

\subsection*{\small c)}

Comparitive analysis
\begin{itemize}
\item Data Model
\item Scalability
\item Query Language
\end{itemize}

\end{document}