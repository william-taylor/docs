\documentclass{article}

% Packages
\usepackage{fuzz}
\usepackage[margin=1.0in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{language=SQL,
  basicstyle={\small\ttfamily},
  belowskip=3mm,
  breakatwhitespace=true,
  breaklines=true,
  classoffset=0,
  columns=flexible,
  commentstyle=\color{dkgreen},
  framexleftmargin=0.5em,
  frameshape={}{}{}{},
  keywordstyle=\color{blue},
  numbers=none,
  numberstyle=\tiny\color{gray},
  showstringspaces=false,
  stringstyle=\color{mauve},
  tabsize=3,
  xleftmargin =0em
}
\definecolor{delim}{RGB}{20,105,176}
\definecolor{numb}{RGB}{106, 109, 32}
\definecolor{string}{rgb}{0.64,0.08,0.08}

\lstdefinelanguage{json}{
    numbers=none,
    numberstyle=\small,
    frame=none,
    rulecolor=\color{black},
    showspaces=false,
    showtabs=false,
    breaklines=false,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
    breakatwhitespace=true,
    basicstyle=\ttfamily\small,
    upquote=true,
    morestring=[b]",
    stringstyle=\color{string},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}
\usepackage{prooftree}

% Metadata
\title{Final Assignment}
\date{\vspace{-1.0cm}18th June 2024}

% Start
\begin{document}
\maketitle

\section*{Q1}

\subsection*{\small a)}


\textbf{Personal Information}
\newline \newline Assumptions:
\begin{itemize}
  \item The requirement to capture gender refers to biological sex, if it refers to gender identity the schema would need to change to support a greater range of values potentially via a lookup table.
\end{itemize}
\begin{schema}{User}
	\underline{userId}: UserId \\
    email: EmailType \\
	firstName: NameType \\
	lastName: NameType \\
    dateOfBirth: DateType \\
    gender: GenderType \\
    height: HeightType \\ 
\end{schema}
\begin{zed}
\textcolor{red}{PK}(User) = \{ userId \} \\
\end{zed}

\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Health Status Data}
\newline \newline Assumptions:
\begin{itemize}
  \item ... 
\end{itemize}

\begin{schema}{HealthReading}
	\underline{readingId}: ReadingId \\
    takenAt: DateTimeType \\
    glucoseLevel: GlucoseType \\
    bloodPressure: PressureType \\ 
    weight: WeightType \\
    userId: UserId \\
\end{schema}
\begin{zed}
\textcolor{red}{PK}(HealthReading) = { readingId } \\
\end{zed}
    
\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Diet Data}
\newline \newline Assumptions:
\begin{itemize}
  \item ...
\end{itemize}

\begin{schema}{Diet}
    dietId: DietId \\
    userId: UserId \\
    date: DateType \\
\end{schema}

\begin{schema}{Meal}
	\underline{mealId}: MealId \\
    dietId: DietId \\
    mealType: MealType \\
    mealSize: SizeType \\
\end{schema}

\begin{schema}{Snack}
	\underline{snackId}: SnackId \\
    dietId: DietId \\
    snackName: SnackNameType \\
    estimatedCalories: CaloriesType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(Diet) = { dietId } \\
\textcolor{red}{PK}(Meal) = { mealId } \\
\textcolor{red}{PK}(Snack) = { snackId } \\
\end{zed}
    
\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Gym Performance Data}
\newline \newline Assumptions:
\begin{itemize}
  \item ...
\end{itemize}

\begin{schema}{Exercise}
	\underline{exerciseId}: ExerciseId \\
    occurredAt: DateTimeType \\
    repetitionsPerSet: \nat \\
    numberOfSets: \nat \\
    weightType: WeightType \\
    weightLevel: WeightLevelType \\
    userId: UserId \\
\end{schema}
\begin{zed}
\textcolor{red}{PK}(Exercise) = { exerciseId } \\
\end{zed}

\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Movement Data}
\newline \newline Assumptions:
\begin{itemize}
  \item ...
\end{itemize}

\begin{schema}{DailyMovement}
	\underline{snapshotId}: SnapshotId \\
    \underline{dailyMovement}: HourlyMovementId \\
    interval: IntervalType \\
    date: DateType \\
    time: TimeType \\
    userId: UserId \\
\end{schema}

\begin{schema}{HourlyMovement}
    \underline{hourlyMovementId}: HourlyMovementId \\
    calories: CaloriesType \\
    distance: DistanceType \\ 
    stairs: \nat \\
    steps: \nat \\
    pace: PaceType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(MovementSnapshot) = { snapshotId } \\
\textcolor{red}{PK}(MovementData) = { dataId } \\
\end{zed}
    

\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Personal Goals}
\newline \newline Assumptions:
\begin{itemize}
  \item message won't be the only attribute 
\end{itemize}

\begin{schema}{Goal}
	\underline{goalId}: GoalId \\
    userId: UserId \\
    startDate: DateType \\
    endDate: DateType \\ 
    targetType: TargetType \\
    targetUnit: TargetUnit \\
    targetValue: TargetValue \\ 
\end{schema}

\begin{schema}{Outcome}
	\underline{outcomeId}: OutcomeId \\
    goalId: GoalId \\
    recordedAt: DateTimeType \\
    status: Status \\
\end{schema}

\begin{schema}{Message}
	\underline{messageId}: MessageId \\
    outcomeId: OutcomeId \\
    subject: SubjectType \\
    message: MessageType \\
\end{schema}

\begin{schema}{Evidence}
	\underline{evidenceId}: EvidenceId \\
    outcomeId: OutcomeId \\
    movementId: MovementId \\
    readingId: ReadingId \\ 
    weightId: WeightId \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(Goal) = { goalId }  \\
\textcolor{red}{PK}(GoalNotification) = { notificationId }  \\
\textcolor{red}{PK}(GoalEvidence) = { evidenceId }  \\
\end{zed}

\pagebreak 

\subsection*{\small b)}

To validate the schema is in the third normal form I need to prove it meets both the first and second normal form first.
\newline
\newline
The provided schema does meet the first normal form as I have eliminated repeating gropus by X.
\newline
\newline
It also meets the second form as each non primary key attribute relates to relation.

\subsection*{\small c)}

C1
\begin{zed}
\forall g: Goal @ \lnot (g.periodEnd < g.periodStart) \\
\end{zed}
C2
\begin{zed}
\forall dm: DailyMovement @ \\
    \t1 dm.calories = sum \\
    \t2 \{ hm: HourlyMovement | (dm.userId, dm.date, dm.pace) = (hm.userId, hm.date, hm.pace) @ hm.calories \} \\
    \t1 dm.distance = sum \\
    \t2 \{ hm: HourlyMovement | (dm.userId, dm.date, dm.pace) = (hm.userId, hm.date, hm.pace) @ hm.distance \} \\
    \t1 dm.stairs = sum \\
    \t2 \{ hm: HourlyMovement | (dm.userId, dm.date, dm.pace) = (hm.userId, hm.date, hm.pace) @ hm.stairs \} \\
    \t1 dm.steps = sum \\
    \t2 \{ hm: HourlyMovement | (dm.userId, dm.date, dm.pace) = (hm.userId, hm.date, hm.pace) @ hm.steps \} \\
\end{zed}
C3
\begin{zed}
\forall d: DateType; u: User @ \\
    \t1 \#\{ g: Goal | u.userId = g.userId \land g.periodStart \leq d \land g.periodEnd > d \} <= 3 \\
\end{zed}
C4
\begin{zed}
\forall o: GoalOutcome @ \\ 
    \t1 o.status \in \{Success, Failure\} \implies (\exists e: GoalEvidence | o.outcomeId = e.outcomeId) \\
\end{zed}
Additional Constraints:
\begin{itemize}
  \item Diet data should have a constraint on date to make sure dietDate is unique per date and user. 
  \item Each movement snapshot should have movement data one for each pace type which can be added as a constraint 
  \item Meal entries should be restricted to one meal type per day 
\end{itemize}

\subsection*{\small d)}

Storage
\newline
Indices (clustered and nonclustered)
\newline
Audit info (do we need to create triggers to capture timestamps)
\newline
Orthagonal design (slit active from non active users of the app)

\pagebreak 
\section*{Q2}

\subsection*{\small a)}

\begin{zed}
    A == Restrict\small{\{userId = currentUserId \land takenAt.year = 2023 \land takenAt.month = February \}}(MovementSnapshot) \\
    B == Restrict\small{\{md.distance >= 1 \land movementPace \in \{ Walked, Ran \}\}} \\
    C == Project\small{\{takenAt.day\}}(Join(A, B)) \\
\end{zed}

\begin{zed}
\{ ms: MovementSnapshot; md: MovementData | \\
    \t1 ms.snapshotId = md.snapshotId \land ms.userId = currentUserId \\
    \t1 ms.takenAt.year = 2023 \land ms.takenAt.month = February \\
    \t1 md.distance >= 1 \land md.movementPace \in \{ Walked, Ran \} @ \\
        \t2 ( day == ms.takenAt.day ) \}
\end{zed}

\subsection*{\small b)}

Need to join to get status.

\begin{zed}
A = Restrict\small{userId = currentUserId}(Goal) \\
B = Restrict\small{goalStart < Feb2023}(A) \\
C = Restrict\small{goalEnd >= Feb2023}(B)
\end{zed}

\begin{zed}
\{ g: Goal | \\
    \t1 g.userId = currentUserId \land \\
    \t1 g.goalStart < Feb2023 \land \\
    \t1 g.goalEnd >= Feb2023 \\
\}
\end{zed}

\subsection*{\small c)}

\begin{zed}
A == Restrict\small{userId = currentUserId \land goal.goalEnd.year = 2023 \land goal.status = Success}(Goal) \\
B == Project\small{month, goalId}(A) \\
C == B GroupBy(count(goalId) as goalsMet) \\
D == C GroupBy(max(goalsMet) as maxGoalsMet) \\
E == Join(C, D) \\
F == Restrict\small{goalsMet = maxGoalsMet}(E) \\ 
G == Project\small{month}(F)
\end{zed}

\begin{zed}
\forall t: Table
\end{zed}

\subsection*{\small d)}

\begin{zed}
A == Restrict{userId = currentUserId \land interval = Daily \land takenAt.year = 2023}(MovementSnapshot) \\
B == Join(A, MovementData) \\ 
C == Project{takenAt.month, calories}(B) \\ 
D == C GroupBy(avg(calories) as averageDailyCalories) \\
\end{zed}

\begin{zed}
\forall t: Table
\end{zed}

\pagebreak 
\section*{Q3}

\subsection*{\small a)}

\begin{lstlisting}[language=sql]
CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);
\end{lstlisting}


\subsection*{\small b)}

\begin{lstlisting}[language=sql]
ALTER TABLE Persons ADD CONSTRAINT CHK_PersonAge CHECK (
    Age>=18 AND City='Sandnes'
);
\end{lstlisting}

\subsection*{\small c)}

\begin{lstlisting}[language=sql]
SELECT 
    x,
    y,
    z
FROM 
    CustomTable 
GROUP BY 
    x,
    y
ORDER BY
    z
\end{lstlisting}

\pagebreak 
\section*{Q4}

\subsection*{\small a)}

Non Relational Design

https://www.mongodb.com/blog/post/building-with-patterns-a-summary

\subsection*{\small b)}

% Query 1 % 
\hspace{0cm}1.
\begin{lstlisting}[language=json]
{
    "query": 100
} 
\end{lstlisting} 
% Query 2 % 
\hspace{0cm}2.
\begin{lstlisting}[language=json]
{                   
    "query": 100
}
\end{lstlisting}
% Query 3 % 
\hspace{0cm}3. 
\begin{lstlisting}[language=json]
{
    "query": 100
}
\end{lstlisting}
% Query 4 % 
\hspace{0cm}4. 
\begin{lstlisting}[language=json]
{
    "query": 100
}
\end{lstlisting}

\subsection*{\small c)}

Comparitive analysis

1) Data Model
2) Scalability
3) Query Language

\end{document}