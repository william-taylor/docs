\documentclass{article}

% Packages
\usepackage{fuzz}
\usepackage[margin=1.0in]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{language=SQL,
  basicstyle={\small\ttfamily},
  belowskip=3mm,
  breakatwhitespace=true,
  breaklines=true,
  classoffset=0,
  columns=flexible,
  commentstyle=\color{dkgreen},
  framexleftmargin=0.5em,
  frameshape={}{}{}{},
  keywordstyle=\color{blue},
  numbers=none,
  numberstyle=\tiny\color{gray},
  showstringspaces=false,
  stringstyle=\color{mauve},
  tabsize=3,
  xleftmargin =0em
}
\definecolor{delim}{RGB}{20,105,176}
\definecolor{numb}{RGB}{106, 109, 32}
\definecolor{string}{rgb}{0.64,0.08,0.08}

\lstdefinelanguage{json}{
    numbers=none,
    numberstyle=\small,
    frame=none,
    rulecolor=\color{black},
    showspaces=false,
    showtabs=false,
    breaklines=false,
    postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{gray}\hookrightarrow\space}},
    breakatwhitespace=true,
    basicstyle=\ttfamily\small,
    upquote=true,
    morestring=[b]",
    stringstyle=\color{string},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}
\usepackage{prooftree}

% Metadata
\title{Final Assignment}
\date{\vspace{-1.0cm}18th June 2024}

% Start
\begin{document}
\maketitle

\section*{Q1}

\subsection*{\small a)}

\textbf{Personal Information}
\newline \newline Assumptions:
\begin{itemize}
  \item That height will be stored as centimeters and there isn't a need support capturing height in either metric or/and imperial units.
  \item That gender doesn't need to support a broad range of values. If it did it would make sense to create a new $Gender$ relation that the $User$ relation can have a foreign key to. 
\end{itemize}
\begin{schema}{User}
	\underline{userId}: UserIdType \\
    emailAddress: EmailAddressType \\
	firstName: NameType \\
	lastName: NameType \\
    dateOfBirth: DateType \\
    gender: GenderType \\
    height: HeightType \\ 
\end{schema}
\begin{zed}
\textcolor{red}{PK}(User) = \{ userId \} \\
\end{zed}

\vspace{0.2cm}
\hspace{-0.5cm}\textbf{Health Status Data}
\newline \newline Assumptions:
\begin{itemize}
  \item That we don't need to track readings submitted together. If it was, introducing a $Submission$ relation and a new foreign key attribute to $HealthReading$ could enable that.
\end{itemize}

\begin{schema}{HealthMetric}
\underline{healthMetricId}: MetricIdType \\
metricName: MetricNameType \\ 
metricUnit: MetricUnitType \\ 
\end{schema}

\begin{schema}{HealthReading}
	\underline{healthReadingId}: ReadingIdType \\
    submissionId: SubmissionId \\
    metricId: MetricIdType \\
    value: MetricValueType \\
    readAt: DateTimeType \\
    userId: UserIdType \\
\end{schema}
\begin{zed}
\textcolor{red}{PK}(HealthMetric) = \{ healthMetricId \} \\
\textcolor{red}{PK}(HealthReading) = \{ healthReadingId \} \\ 
\newline \\ 
(HealthReading, HealthMetric) \mapsto \{ metricId \mapsto healthMetricId \} \in \textcolor{red}{FK} \\
(HealthReading, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
\end{zed}
    
\hspace{-0.5cm}\textbf{Diet Data}
\newline \newline Assumptions:
\begin{itemize}
  \item That meals, food and drink is meant to capture diet information at a very high level and there is no need to store a broad defined list of food/drink types/names. 
  \item That calories should only be stored for Food/Drinks with drinks stored by type and glasses consumed and food stored by name and quantity.
\end{itemize}

\begin{schema}{Diet}
    \underline{dietId}: DietId \\
    userId: UserIdType \\
    date: DateType \\
\end{schema}

\begin{schema}{Meal}
	\underline{mealId}: MealId \\
    dietId: DietId \\
    mealType: MealType \\
    mealSize: SizeType \\
\end{schema}

\begin{schema}{Food}
	\underline{foodId}: FoodId \\
    dietId: DietId \\
    foodName: FoodNameType \\
    calories: CaloriesType \\
    quantity: \nat_1 \\
\end{schema}

\begin{schema}{Drink}
	\underline{drinkId}: DrinkId \\
    dietId: DietId \\
    drinkType: DrinkType \\
    calories: CaloriesType \\
    glasses: \nat_1 \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(Diet) = \{ dietId \} \\
\textcolor{red}{PK}(Meal) = \{ mealId \} \\
\textcolor{red}{PK}(Food) = \{ foodId \} \\
\textcolor{red}{PK}(Drink) = \{ drinkId \} \\
\newline \\ 
(Diet, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
(Meal, Diet) \mapsto \{ dietId \mapsto dietId \} \in \textcolor{red}{FK} \\
(Food, Diet) \mapsto \{ dietId \mapsto dietId \} \in \textcolor{red}{FK} \\
(Drink, Diet) \mapsto \{ dietId \mapsto dietId \} \in \textcolor{red}{FK} \\
\end{zed}
    
\hspace{-0.5cm}\textbf{Gym Performance Data}

\begin{schema}{Exercise}
	\underline{exerciseId}: ExerciseIdType \\
	exerciseName: ExerciseNameType
\end{schema}

\begin{schema}{Workout}
	\underline{workoutId}: WorkoutIdType \\
    occurredAt: DateTimeType \\
    userId: UserIdType \\
\end{schema}

\begin{schema}{WorkoutSession}
    \underline{workoutSessionId}: SessionIdType \\
    workoutId: WorkoutIdType \\
    exerciseId: ExerciseIdType \\
    weightLevel: WeightLevelType \\
    numberOfSets: \nat_1 \\
    repetitionsPerSet: \nat_1  \\
\end{schema}
\begin{zed}
\textcolor{red}{PK}(Exercise) = \{ exerciseId \} \\
\textcolor{red}{PK}(Workout) = \{ workoutId \} \\
\textcolor{red}{PK}(WorkoutSession) = \{ workoutSessionId \} \\
\newline \\ 
(WorkoutSession, Workout) \mapsto \{ workoutId \mapsto workoutId \} \in \textcolor{red}{FK} \\
(WorkoutSession, Exercise) \mapsto \{ exerciseId \mapsto exerciseId \} \in \textcolor{red}{FK} \\
\end{zed}

\hspace{-0.5cm}\textbf{Movement Data}

\begin{schema}{DailyMovement}
    \underline{dailyMovementId}: DailyMovementId \\
    calories: CaloriesType \\
    distance: DistanceType \\ 
    stairs: \nat \\
    steps: \nat \\
    pace: PaceType \\
    date: DateType \\
    userId: UserIdType \\
\end{schema}

\begin{schema}{HourlyMovement}
    \underline{hourlyMovementId}: HourlyMovementId \\
    calories: CaloriesType \\
    distance: DistanceType \\ 
    stairs: \nat \\
    steps: \nat \\
    pace: PaceType \\
    date: DateType \\
    time: TimeType \\
    userId: UserIdType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(DailyMovement) = \{ dailyMovementId \} \\
\textcolor{red}{PK}(HourlyMovement) = \{ hourlyMovementId \} \\
\newline \\ 
(DailyMovement, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
(HourlyMovement, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
\end{zed}
    
\hspace{-0.5cm}\textbf{Personal Goals}

\begin{schema}{Goal}
	\underline{goalId}: GoalId \\
    userId: UserIdType \\
    startOn: DateTimeType \\
    endAt: DateTimeType \\ 
    targetType: TargetType \\
    targetUnit: TargetUnit \\
    targetValue: TargetValue \\ 
\end{schema}

\begin{schema}{GoalOutcome}
	\underline{outcomeId}: OutcomeId \\
    goalId: GoalId \\
    achievedAt: DateTimeType \\
    status: Status \\
\end{schema}

\begin{schema}{GoalMessage}
	\underline{messageId}: MessageId \\
    outcomeId: OutcomeId \\
    subject: SubjectType \\
    message: MessageType \\
\end{schema}

\begin{schema}{GoalEvidence}
	\underline{evidenceId}: EvidenceId \\
    outcomeId: OutcomeId \\
    dailyMovementId: DailyMovementId \\
    hourlyMovementId: HourlyMovementId \\
    healthReadingId: HealthReadingId \\
    workoutSessionId: WorkoutSessionIdType \\
\end{schema}

\begin{zed}
\textcolor{red}{PK}(Goal) = \{ goalId \}  \\
\textcolor{red}{PK}(GoalOutcome) = \{ outcomeId \}  \\
\textcolor{red}{PK}(GoalNotification) = \{ notificationId \}  \\
\textcolor{red}{PK}(GoalEvidence) = \{ evidenceId \}  \\
\newline \\ 
(Goal, User) \mapsto \{ userId \mapsto userId \} \in \textcolor{red}{FK} \\
(GoalOutcome, Goal) \mapsto \{ goalId \mapsto goalId \} \in \textcolor{red}{FK} \\
(GoalMessage, GoalOutcome) \mapsto \{ outcomeId \mapsto outcomeId \} \in \textcolor{red}{FK} \\
(GoalEvidence, DailyMovement) \mapsto \{ dailyMovementId \mapsto dailyMovementId \} \in \textcolor{red}{FK} \\
(GoalEvidence, HourlyMovement) \mapsto \{ hourlyMovementId \mapsto hourlyMovementId \} \in \textcolor{red}{FK} \\
(GoalEvidence, HealthReading) \mapsto \{ healthReadingId \mapsto healthReadingId \} \in \textcolor{red}{FK} \\
(GoalEvidence, WorkoutSession) \mapsto \{ workoutSessionId \mapsto workoutSessionId \} \in \textcolor{red}{FK} \\
\end{zed}

\subsection*{\small b)}

The schema has been designed to be in 3NF but to meet this standard I needed to make sure the schema meets the rules set out for 1NF and 2NF. \\
\newline
I've made sure the schema is in 1NF by flattening each relation removing repeating groups ensuring each attribute in each relation contains only a single value. \\ 
\newline
To meet the rules of 2NF I identified partial dependencies and moved them into their own relations to ensure that every non primary key attribute is fully dependent on any candidate key in the relation. \\
\newline
Finally, to meet 3NF I identified and removed any attributes that were transitively dependent on the primary key moving them into their own relation as well, removing additional redundancy. 

\subsection*{\small c)}

\textbf{\small{C1}}
\begin{zed}
\forall g: Goal @ \lnot (g.endDate < g.startDate) \\
\end{zed}
\textbf{\small{C2}}
\begin{zed}
\forall dm: DailyMovement @ \\
    \t1 d.calories = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.calories \} \\
    \t1 d.distance = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.distance \} \\
    \t1 d.stairs = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.stairs \} \\
    \t1 d.steps = sum\{ h: HourlyMovement | (d.userId, d.date, d.pace) = (h.userId, h.date, h.pace) @ h.steps \} \\
\end{zed}
\textbf{\small{C3}}
\begin{zed}
\forall u: User; d: DateType @ \\
\t1 \#\{ g: Goal | g.userId = u.userId \land g.startsAt \leq d \land g.endsAt > d \} \leq 3
\end{zed}
\textbf{\small{C4}}
\begin{zed}
\forall o: GoalOutcome @ \\
\t1 o.status \in \{Success, Failure\} \implies (\exists e: GoalEvidence | o.outcomeId = e.outcomeId) \\
\end{zed}
\textbf{\small{Additional Constraints}}

\begin{itemize}
  \item It would make sense to introduce a constraint to make sure there is at most 1 entry in the $Diet$ relation for each user for each day, ensuring all $Meal$ / $Food$ / $Drink$ entries are grouped together in a consistent manner.
  \item For goals it would make sense to ensure consistency between the $userId$ referenced for the goal and the evidence tied to the $GoalOutcome$. It would also make sense to ensure the $achievedAt$ is not before or after the goal period captured in the $startOn$ and $endAt$ attirbutes in the $Goal$ relation.
\end{itemize}

\subsection*{\small d)}

I would want to ask various questions to dive deeper into the requirements regarding the type of data we would store. When it comes to attributes like a user’s $height$ or a health reading’s $value$ it would make sense establish the requirements around precision to help optimized the solution a database storage level. There are various like values such as $Gender$, $MetricUnitType$, $DrinkType$ which would be good to get more details to be able to firmly say should they enum style types or have their own relations to new values can be added easier in future. \\
\newline
I'd like to also ask for more detailed examples of how data would be queried. This would help identify important attributes in the relations that would potentially benefit from having an index applied. For example would a regular index on the $GoalOutcome$ $status$ attribute make sense so users could retrieve failed goals easier? Or potentially a clustered index $startsOn$ attribute in the $Goal$ relation to users can query goals that started within a given range efficiently. \\
\newline
I would also ask about the amount of data being stored and estimates for expected reads and writes over a typical period. As it would be good to clarify the required performance and scaling needs when implementing the schema. As we may need to apply techniques such as read replicas, partitions, sharding and potentially denormalization to ensure we meet expectations on performance and scale gracefully.

\pagebreak

\section*{Q2}

For answering these questions I've assumed the presence of the $currentUser$ variable which is of type $User$ that captures the user executing the query. I've also assumed that the $DateType$ type used in the schema has year, month and day variables that are natural numbers. Finally I've assumed that $distance$ in the $DailyMovement$ relation is stored as miles and no converstion is required for the query.

\subsection*{\small a)}

\begin{zed}
\{ d: DailyMovement | \\
    \t1 d.userId = currentUser.userId \land \\
    \t1 d.date.year = 2023 \land d.date.month = 2 \land \\
    \t1 d.distance \geq 1 \land d.pace \in \{ Walked, Ran \} \\
        \t2 @ \lblot day == d.date.day \rblot \}
\end{zed}

\subsection*{\small b)}
\begin{zed}
\{ g: Goal | \\
    \t1 g.userId = currentUser.userId \land \\
    \t1 g.startAt.month \leq 1 \land g.startAt.year \leq 2023 \\
    \t1 g.endOn.month \geq 1 \land g.endOn.year \geq 2023 \} \\
\end{zed}

\subsection*{\small c)}
\begin{zed}
A == Restrict\{userId = currentUser.userId \}(Goal) \\
B == Restrict\{achievedAt.year = 2023 \land status = Success \}(GoalOutcome) \\
C == Project\{achievedAt.year, achievedAt.month, goalId\}(Join(A, B)) \\
D == C\ GroupBy(Count(goalId)\ as\ metPerMonth) \\
E == Project\{year, metPerMonth\}(D) \\
F == E\ GroupBy(Max(metPerMonth)\ as\ maxGoalsMet) \\
G == Project\{month\}(Restrict\{maxGoalsMet = metPerMonth\}(Join(E, F)) \\
\end{zed}

\subsection*{\small d)}
\begin{zed}
A == Restrict\{userId = currentUser.userId\}(DailyMovement) \\
B == Restrict\{date.year = 2023 \}(A) \\
C == Project\{date, calories\}(B) \\
D == C\ GroupBy(Sum(calories)\ as\ dailyTotal) \\ 
E == Project\{date.month, dailyTotal\}(D) \\ 
F == E\ GroupBy(Avg(dailyTotal)\ as\ dailyAverage) \\
\end{zed}

\pagebreak

\section*{Q3}

\subsection*{\small a)}

\begin{lstlisting}[language=sql]
CREATE TABLE Persons (
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);
\end{lstlisting}


\subsection*{\small b)}

C1 - Check - column
C2 - Trigger - before insert
C3 - Check - column
C4 - Trigger - before insert
\begin{lstlisting}[language=sql]
ALTER TABLE Persons ADD CONSTRAINT CHK_PersonAge CHECK (
    Age>=18 AND City='Sandnes'
);
\end{lstlisting}

\subsection*{\small c)}

\begin{lstlisting}[language=sql]
SELECT 
    x,
    y,
    z
FROM 
    CustomTable 
GROUP BY 
    x,
    y
ORDER BY
    z
\end{lstlisting}

\section*{Q4}

\subsection*{\small a)}

Non Relational Design

https://www.mongodb.com/blog/post/building-with-patterns-a-summary

\subsection*{\small b)}

% Query 1 % 
\hspace{0cm}1.
\begin{lstlisting}[language=json]
{
    "query": 100
} 
\end{lstlisting} 
% Query 2 % 
\hspace{0cm}2.
\begin{lstlisting}[language=json]
{                   
    "query": 100
}
\end{lstlisting}
% Query 3 % 
\hspace{0cm}3. 
\begin{lstlisting}[language=json]
{
    "query": 100
}
\end{lstlisting}
% Query 4 % 
\hspace{0cm}4. 
\begin{lstlisting}[language=json]
{
    "query": 100
}
\end{lstlisting}

\subsection*{\small c)}

Comparitive analysis

1) Data Model
2) Scalability
3) Query Language

\end{document}