\documentclass{article}

% Packages
\usepackage{fuzz}
\usepackage{geometry}
\usepackage{listings}

% Metadata
\title{SBM - Final Assignment}
\date{18th March 2025}
\author{Anonymous}

\begin{document}
\maketitle

\pagebreak 

% Question 1
\section*{Q1}

\subsection*{Part A}

The state model below makes multiple assumptions. As it was stated that a timeline can be associated with at most one multiverse, I’ve assumed timelines don’t necessarily need to be linked to a multiverse when created, but they can be linked later. it has also been assumed that delete operations should clean up all associated states and not only be available when none exists. \\
\newline
The model introduces a timeline and character function through axiomatic definitions to circumvent ProZ's component selection limitations. To meet ProZ's initialisation requirements, one and only one initialisation operation with no inputs has also been defined. \\
\newline
Promotion was adopted for the model to split concerns between how we change character state and then record that in the global state increasing readability. Additional functions were also defined to help improve the readability of output operators when extracting a set of character state properties.  \\
\newline
Finally, it was assumed that embellishing the types in the model, such as the multiverse, timeline, and character types, was not expected beyond the scope of what was laid out in the scenario to keep the model terse.

\begin{zed}
[Multiverse, Timeline, Character] \\
LivingStatus ::= dead | alive \\
BeingType ::= human | immortal | superhero \\
CharacterLocation == Timeline \cross Character \\
\end{zed}

\begin{axdef}
timeline: CharacterLocation \fun Timeline \\
\where
\forall x: Timeline; y: Character @ \\
\t1 timeline(x, y) = x \\
\end{axdef}

\begin{axdef}
character: CharacterLocation \fun Character \\
\where
\forall x: Timeline; y: Character @ \\
\t1 character(x, y) = y \\
\end{axdef} 

\begin{schema}{CharacterState}
being: BeingType \\
status: LivingStatus \\
lives: 0 \upto 3  \\ 
maxLives: 1 \upto 3 \\ 
\where
being = immortal \implies (maxLives, lives, status) = (1, 1, alive) \\
being = human \implies maxLives = 1 \\
lives \leq maxLives \\
\end{schema}

\begin{schema}{Megaverse}
multiverses: \power Multiverse \\
characters: \power Character \\
timelines: \power Timeline \\ 
multiverseTimelines: Multiverse \rel Timeline \\
characterStates: CharacterLocation \pfun CharacterState \\
\where
\dom multiverseTimelines \subseteq multiverses \\ 
\ran multiverseTimelines \subseteq timelines \\ 
\forall t: timelines @ \#\{ m: multiverses | (m, t) \in multiverseTimelines \} \leq 1 \\
\{ p: \dom characterStates @ timeline(p) \} \subseteq timelines \\
\{ p: \dom characterStates @ character(p) \} \subseteq characters \\
\end{schema}

\begin{schema}{Init}
Megaverse \\ 
\where
multiverses = \emptyset \\
characters = \emptyset \\ 
timelines = \emptyset \\
multiverseTimelines = \emptyset \\
characterStates = \emptyset \\
\end{schema}

\begin{schema}{CreateMultiverse}
\Delta Megaverse \\
m?: Multiverse \\
\where
m? \notin multiverses \\
characters' = characters \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
multiverses' = multiverses \cup \{ m? \} \\ 
characterStates' = characterStates \\
\end{schema}

\begin{schema}{ResetMultiverse}
\Delta Megaverse \\
m?: Multiverse \\
\where
m? \in multiverses \\
multiverseTimelines \limg \{ m? \} \rimg \neq \emptyset \\
characters' = characters \\
timelines' = timelines \setminus multiverseTimelines \limg \{ m? \} \rimg   \\
multiverses' = multiverses \\
multiverseTimelines' = \{ m? \} \ndres multiverseTimelines \\
characterStates' = \{ p: \dom characterStates | \\
\t1 timeline(p) \in multiverseTimelines \limg \{ m? \} \rimg 
\} \ndres characterStates \\
\end{schema} 

\begin{schema}{DeleteMultiverse}
\Delta Megaverse \\
m?: Multiverse \\
\where
m? \in multiverses \\
characters' = characters \\
timelines' = timelines \setminus multiverseTimelines \limg \{ m? \} \rimg   \\
multiverses' = multiverses \setminus \{ m? \} \\
multiverseTimelines' = \{ m? \} \ndres multiverseTimelines \\
characterStates' = \{ p: \dom characterStates | timeline(p) \\
\t1 \in multiverseTimelines \limg \{ m? \} \rimg \} \ndres characterStates \\
\end{schema} 

\begin{schema}{CreateTimeline}
\Delta Megaverse \\
t?: Timeline \\
\where
t? \notin timelines \\ 
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\ 
timelines' = timelines \cup \{ t? \} \\
multiverseTimelines' = multiverseTimelines \\
characterStates' = characterStates \\
\end{schema}

\begin{schema}{AddTimelineToMultiverse}
\Delta Megaverse \\
t?: Timeline \\
m?: Multiverse \\
\where
(m?, t?) \notin multiverseTimelines \\ 
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \cup \{ m? \mapsto t? \} \\
characterStates' = characterStates \\
\end{schema}

\begin{schema}{RemoveTimelineFromMultiverse}
\Delta Megaverse \\
t?: Timeline \\
m?: Multiverse \\
\where
(m?, t?) \in multiverseTimelines \\ 
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \setminus \{ m? \mapsto t? \} \\
characterStates' = characterStates \\
\end{schema}

\begin{schema}{MoveTimeline}
\Delta Megaverse \\
t?: Timeline \\
s?: Multiverse \\
d?: Multiverse \\
\where
s? \neq d? \\
\{ s?, d? \} \subseteq multiverses \\
s? \mapsto t? \in multiverseTimelines \\
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\
timelines' = timelines \\ 
multiverseTimelines' = multiverseTimelines \setminus \{ s? \mapsto t? \} \cup \{ d? \mapsto t? \} \\
\end{schema}

\begin{schema}{ResetTimeline}
\Delta Megaverse \\
t?: Timeline \\
\where
t? \in timelines \\
\{ p: \dom characterStates | t? = timeline(p) \} \neq \emptyset \\
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = \{ p: \dom characterStates | timeline(p) = t? \} \ndres characterStates \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \nrres \{ t? \} \\
\end{schema}

\begin{schema}{DeleteTimeline}
\Delta Megaverse \\
t?: Timeline \\
\where
t? \in timelines \\
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = \{ p: \dom characterStates | timeline(p) = t? \} \ndres characterStates \\
timelines' = timelines \setminus \{ t? \} \\
multiverseTimelines' = multiverseTimelines \nrres \{ t? \} \\
\end{schema}

\begin{schema}{CreateCharacter}
\Delta Megaverse \\
c?: Character \\
\where 
c? \notin characters \\
characters' = characters \cup \{ c? \} \\
multiverses' = multiverses \\
characterStates' = characterStates \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{DeleteCharacter}
\Delta Megaverse \\
c?: Character \\
\where 
c? \in characters \\
characters' = characters \setminus \{ c? \} \\
multiverses' = multiverses \\
characterStates' = \{ p: \dom characterStates | character(p) = c? \} \ndres characterStates \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{AddCharacterToTimeline}
\Delta Megaverse \\
m?: Multiverse \\
t?: Timeline \\
c?: Character \\
s?: CharacterState \\ 
\where
c? \in characters \\
(s?).status = alive \\
(s?).lives \neq 0 \\
(m? \mapsto t?) \in multiverseTimelines \\
(t? \mapsto c?) \notin \dom characterStates  \\
multiverses' = multiverses \\
characters' = characters \\
characterStates' = characterStates \cup \{ (t? \mapsto c?) \mapsto s? \} \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{RemoveCharacterFromTimeline}
\Delta Megaverse \\
m?: Multiverse \\
t?: Timeline \\
c?: Character \\
\where
(m? \mapsto t?) \in multiverseTimelines \\
(t? \mapsto c?) \in \dom characterStates  \\
multiverses' = multiverses \\
characters' = characters \\
characterStates' = \{ (t? \mapsto c?) \} \ndres characterStates \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{KillCharacterLocal} 
\Delta CharacterState \\
\where
being \neq immortal \\
status = alive \\
lives' = lives - 1 \\
maxLives' = maxLives \\
status' = dead \\
being' = being \\
\end{schema}

\begin{schema}{ReanimateCharacterLocal}
\Delta CharacterState \\
\where
status = dead \\
lives > 0 \\
being = superhero \\
maxLives' = maxLives \\
lives' = lives \\
being' = being \\
status' = alive \\
\end{schema}

\begin{schema}{ChangeToHumanLocal}
\Delta CharacterState \\
\where
being = immortal \\
lives' = 1 \\
maxLives' = 1 \\
being' = human \\
status' = alive \\
\end{schema}

\begin{schema}{ChangeToSuperheroLocal}
\Delta CharacterState \\
l?: 2 \upto 3 \\
\where
status = alive \\
being = human \\
lives' = l? \\
maxLives' = l? \\
status' = status \\
being' = superhero \\
\end{schema}

\begin{schema}{PromoteCharacterState}
\Delta Megaverse \\
\Delta CharacterState \\
c?: Character \\
t?: Timeline \\ 
\where 
(t?, c?) \in \dom characterStates \\ 
\theta CharacterState = characterStates(t?, c?) \\
characterStates' = characterStates \oplus \{ (t?, c?) \mapsto \theta CharacterState' \}   \\
multiverses' = multiverses \\
characters' = characters \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{zed}
GlobalKillCharacter \defs \\
\t1 \exists \Delta CharacterState @ KillCharacterLocal \land PromoteCharacterState \\ 
\end{zed}

\begin{zed}
GlobalReanimateCharacter \defs \\
\t1 \exists \Delta CharacterState @ ReanimateCharacterLocal \land PromoteCharacterState \\
\end{zed}

\begin{zed}
GlobalChangeToHuman \defs \\ 
\t1 \exists \Delta CharacterState @ ChangeToHumanLocal \land PromoteCharacterState \\
\end{zed}

\begin{zed}
GlobalChangeToSuperhero \defs \\
\t1 \exists \Delta CharacterState @ ChangeToSuperheroLocal \land PromoteCharacterState \\
\end{zed}

\begin{axdef}
beingAndStatus: CharacterState \fun BeingType \cross LivingStatus \\
\where
\forall state: CharacterState @ \\
\t1 beingAndStatus(state) = (state.being, state.status) \\
\end{axdef}

\begin{schema}{LivingStatusForCharactersInTimeline}
\Xi Megaverse \\
t?: Timeline \\ 
r!: \power (Character \cross LivingStatus) \\
\where 
t? \in timelines \\
r! = \{ c: characters | (t?, c) \in \dom characterStates @ \\
\t1 c \mapsto (characterStates(t?,c)).status
\} \\ 
\end{schema}

\begin{schema}{CharacterStatusAcrossAllTimelines}
\Xi Megaverse \\
c?: Character \\ 
r!: \power (Timeline \cross (BeingType \cross LivingStatus)) \\
\where 
c? \in characters \\
r! = \{ t: timelines | (t, c?) \in \dom characterStates @  \\
\t1 t \mapsto beingAndStatus(characterStates((t, c?)))   
\} \\ 
\end{schema}
\pagebreak

\subsection*{Part B}

\vspace{0.5cm}
\begin{verbatim}
MACHINE Megaverse
  SETS 
    MULTIVERSE;
    TIMELINE;
    CHARACTER;
    LIVING_STATUS = { dead, alive };
    BEING_TYPE = { human, immortal, superhero }
  DEFINITIONS
    CHARACTER_STATE == 
      struct(being: BEING_TYPE, status: LIVING_STATUS, lives: 0..3, maxLives: 1..3);
    CHARACTER_LOCATION == TIMELINE * CHARACTER;
    BEING_AND_STATUS(s) == (s'being, s'status) 
  VARIABLES
    multiverses, timelines, multiverseTimelines, characters, characterStates
  INVARIANT
    multiverses: POW(MULTIVERSE)
    &
    timelines: POW(TIMELINE)
    & 
    characters: POW(CHARACTER)
    &
    multiverseTimelines: MULTIVERSE <-> TIMELINE
    &
    characterStates: CHARACTER_LOCATION +-> CHARACTER_STATE
    &
    dom(multiverseTimelines) <: multiverses
    &
    ran(multiverseTimelines) <: timelines
    &
    { p•p: dom(characterStates) | prj1(p) } <: timelines
    &
    { p•p: dom(characterStates) | prj2(p) } <: characters
    &
    !(s).(s: ran(characterStates) => s'lives <= s'maxLives)
    &
    !(s).(s: ran(characterStates) & s'being = human => s'maxLives = 1)
    &
    !(s).(s: ran(characterStates) & s'being = immortal =>
        (s'maxLives, s'lives, s'status) = (1, 1, alive))
    &
    !(t).(t: timelines => 
        card({ m•m: multiverses & (m,t): multiverseTimelines | (m,t) }) <= 1)
\end{verbatim}
\pagebreak
\begin{verbatim}
  INITIALISATION
    multiverses := {}
    ||
    timelines := {}
    ||
    characters := {}
    ||
    multiverseTimelines := {}
    ||
    characterStates := {}
  OPERATIONS
    CreateMultiverse(m) =
      PRE
        m: MULTIVERSE 
        &
        m/: multiverses
      THEN
        multiverses := multiverses \/ { m }
      END;
    ResetMultiverse(m) =
      PRE
        m: MULTIVERSE 
        &
        m: multiverses
        &
        multiverseTimelines[{ m }] /= {}
      THEN
        timelines := timelines \ multiverseTimelines[{ m }];
        characterStates := { p|p: dom(characterStates) & 
            prj1(p): multiverseTimelines[{ m }] } <<| characterStates; 
        multiverseTimelines := { m } <<| multiverseTimelines
      END;
    DeleteMultiverse(m) =
      PRE
        m: MULTIVERSE
        &
        m: multiverses
      THEN
        multiverses := multiverses \ { m };
        timelines := timelines \ multiverseTimelines[{ m }];
        characterStates := { p|p: dom(characterStates) & 
          prj1(p): multiverseTimelines[{ m }] } <<| characterStates; 
        multiverseTimelines := { m } <<| multiverseTimelines
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    CreateTimeline(t) =
      PRE
        t: TIMELINE
        &
        t/: timelines
      THEN
        timelines := timelines \/ { t }
      END;
    ResetTimeline(t) =
      PRE
        t: TIMELINE
        &
        t: timelines
        &
        { p|p: dom(characterStates) & t = prj1(p) } /= {}
      THEN
        multiverseTimelines := multiverseTimelines |>> { t }; 
        characterStates := { p|p: dom(characterStates) & prj1(p) = t }
            <<| characterStates 
      END;
    DeleteTimeline(t) =
      PRE
        t: TIMELINE
        &
        t: timelines
      THEN
        multiverseTimelines := multiverseTimelines |>> { t }; 
        timelines := timelines \ { t };
        characterStates := { p|p: dom(characterStates) & prj1(p) = t } 
            <<| characterStates
      END;
    AddTimelineToMultiverse(t, m) =
      PRE
        t: TIMELINE
        &
        m: MULTIVERSE
        &
        t: timelines
        &
        m: multiverses
        &
        t /: ran(multiverseTimelines)
      THEN
        multiverseTimelines := multiverseTimelines \/ { m |-> t }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    RemoveTimelineFromMultiverse(t, m) =
      PRE
        t: TIMELINE
        &
        m: MULTIVERSE
        &
        t: timelines
        &
        m: multiverses
        &
        m |-> t : multiverseTimelines
      THEN
        multiverseTimelines := multiverseTimelines \ { m |-> t }
      END;
    MoveTimeline(t, s, d) =
      PRE
        t: TIMELINE
        & 
        s: MULTIVERSE
        &
        d: MULTIVERSE
        &
        t: timelines
        &
        s /= d
        &
        s |-> t : multiverseTimelines
        &
        {s, d} <: multiverses
      THEN
        multiverseTimelines := multiverseTimelines \ { s |-> t } \/ { d |-> t }
      END;
    CreateCharacter(c) =
      PRE
        c: CHARACTER 
        &
        c/: characters
      THEN
        characters := characters \/ { c }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    DeleteCharacter(c) =
      PRE
        c: CHARACTER
        &
        c: characters
      THEN
        characters := characters \ { c };
        characterStates := { p•p: dom(characterStates) & prj2(p) = c | 
          (prj1(p), c) } <<| characterStates 
      END;
    AddCharacterToTimeline(m, t, c, s) =
      PRE
        m: MULTIVERSE
        &
        t: TIMELINE
        &
        c: CHARACTER
        &
        s: CHARACTER_STATE
        &
        c: characters
        &
        s'status = alive
        & 
        s'lives /= 0 
        &
        s'lives <= s'maxLives
        &
        (m |-> t): multiverseTimelines  
        &
        (t |-> c)/: dom(characterStates)
        &
        (s'being = human => s'maxLives = 1)
        &
        (s'being = immortal => (s'maxLives, s'lives, s'status) = (1, 1, alive))
      THEN
        characterStates := characterStates \/ { (t |-> c) |-> s }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    RemoveCharacterFromTimeline(m, t, c) =
      PRE
        m: MULTIVERSE
        &
        t: TIMELINE
        &
        c: CHARACTER 
        &
        (m |-> t): multiverseTimelines
        &
        (t |-> c): dom(characterStates)
      THEN
        characterStates := { t |-> c } <<| characterStates
      END;
    ChangeToHuman(t,c) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'being = immortal
      THEN
        characterStates(t,c) := rec(being: human, status: alive, lives: 1, maxLives: 1)
      END;
    ChangeToSuperhero(t,c,l) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        l: 2..3
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'being = human
        & 
        characterStates((t,c))'status = alive
      THEN
        characterStates(t,c) := rec(being: superhero, status: alive, lives: l, maxLives: l)
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    KillCharacter(c, t) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'status = alive
        &
        characterStates((t, c))'being: { human, superhero }
      THEN
        LET s BE s = characterStates(t,c) IN 
          characterStates(t,c) := 
            rec(being: s'being, status: dead, lives: s'lives - 1, maxLives: s'maxLives)
        END
      END;
    ReanimateCharacter(t, c) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'status = dead
        &
        characterStates((t,c))'lives > 0
      THEN
        LET s BE s = characterStates(t,c) IN 
          characterStates(t,c) := 
            rec(being: s'being, status: alive, lives: s'lives, maxLives: s'maxLives)
        END
      END;
    r <-- LivingStatusForCharactersInTimeline(t) = 
      PRE
        t: TIMELINE
        &
        t: timelines
        &
        r: POW(CHARACTER * LIVING_STATUS)
      THEN 
        r := { c•c: characters & (t,c): dom(characterStates) | 
          c |-> characterStates(t, c)'status }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    r <-- CharacterStatusAcrossAllTimelines(c) =
      PRE
        c: CHARACTER
        &
        c: characters
        &
        r: POW(TIMELINE * (BEING_TYPE * LIVING_STATUS))
      THEN
        r := { t•t: timelines & (t,c): dom(characterStates) | 
          t |-> BEING_AND_STATUS(characterStates(t,c)) }
      END
END
\end{verbatim}
\pagebreak

\subsection*{Part C}

It would make sense to expand the details we capture in the CharacterState schema to extend the model. We currently have a BeingType free type, but it is overloaded and expresses multiple things together, which is somewhat limiting. What if we wanted a non-human character to be capable of being a superhero? How might we represent a character with powers but may be a villain in the story? For this, additional free types have been created below. 
\begin{zed}
Mortality ::= mortal | immortal \\
Alignment ::= neutral | hero | villan \\
Power ::= enhanced | mutant | magic | cosmic \\
Species ::= human | alien | titan | android \\
\end{zed}

\hspace{-0.64cm} Introducing the first of many state-based problems: If humans are classified in terms of species, how do we determine whether they have powers? We can solve this with another free type with a constructor that allows us to express whether the character does not have any powers or if they do what it is explicitly. 
\begin{zed}
Powers ::= none | some \ldata Power \rdata \\
\end{zed}

\hspace{-0.64cm} As these are related to a character's state and not their core definition, we add these properties to the CharacterState schema, which has knock-on effects. Requiring updates to the constraints to point them at the new morality and powers attributes instead of the existing type attribute.

\begin{schema}{CharacterState}
alignment: Alignment \\
mortality: Mortality \\
powers: Powers \\
species: Species \\
lives: 0 \upto 3  \\ 
maxLives: 1 \upto 3 \\ 
status: LivingStatus \\
\where
mortality = immortal \implies (maxLives, lives, status) = (1, 1, alive) \\
powers = none \implies maxLives = 1 \\ 
lives \leq maxLives \\
\end{schema}

\hspace{-0.7cm} This introduces a new problem. We have ChangeToHuman and ChangeToSuperhero operations that do not make much sense with these new attributes. Should an alien immortal become human if they give up their immortality? Can only humans become superheroes? To resolve these restrictions and inconsistencies, redefining them as GainPowers and GiveUpImmortality made sense. This incorporates the new attributes to expand the possible states in the model. \\
\newline
The GainPowers operator now accepts alignment and power as inputs so they can be declared when a character gains superpowers. The GivingUpImmortality operation now updates the character's mortality status, leaving species untouched. Precondition updates were needed for all operations to move to the new attributes and for them to be specified explicitly on how they changed when the operation was executed.

\begin{schema}{KillCharacterLocal} 
\Delta CharacterState \\
\where
status = alive \\
mortality \neq immortal \\
alignment' = alignment \\
mortality' = mortality \\
powers' = powers \\ 
species' = species \\
lives' = lives - 1 \\
maxLives' = maxLives \\
status' = dead \\
\end{schema}

\begin{schema}{ResurrectCharacterLocal}
\Delta CharacterState \\
\where
lives > 0 \\
status = dead \\
powers \neq none \\ 
alignment' = alignment \\
mortality' = mortality \\
powers' = powers \\ 
species' = species \\
lives' = lives \\
maxLives' = maxLives \\
status' = alive \\
\end{schema}

\begin{schema}{GainPowersLocal}
\Delta CharacterState \\
p?: Power \\
a?: Alignment \\
l?: 2 \upto 3 \\
\where
status = alive \\ 
species = human \\
powers = none \\
alignment' = a? \\
mortality' = mortality \\
powers' = some(p?) \\ 
species' = species \\
lives' = l? \\
maxLives' = l? \\
status' = status \\
\end{schema}

\begin{schema}{GiveUpImmortalityLocal}
\Delta CharacterState \\
\where
mortality = immortal \\
alignment' = alignment \\
mortality' = mortality \\
powers' = powers \\ 
species' = species \\
lives' = 1 \\
maxLives' = 1 \\
status' = alive \\
\end{schema}

\hspace{-0.7cm} Finally, with our new and updated operations, we need to define them in the context of the global state schema so these local operations can be promoted from CharacterState to the Megaverse.

\begin{zed}
GlobalGiveUpImmortality \defs \exists \Delta CharacterState @ GiveUpImmortalityLocal \land PromoteCharacterState \\
GlobalResurrectCharacter \defs \exists \Delta CharacterState @ ResurrectCharacterLocal \land PromoteCharacterState \\
GlobalKillCharacter \defs \exists \Delta CharacterState @ KillCharacterLocal \land PromoteCharacterState \\ 
GlobalGainPowers \defs \exists \Delta CharacterState @ GainPowersLocal \land PromoteCharacterState \\
\end{zed}

\hspace{-0.64cm} Adding these extensions to the B model starts with new sets for our new free type definitions. However, the Powers free type must be declared a full-free type in B as it cannot be expressed as a set. We can then add the new attributes to the CharacterState struct.

\begin{verbatim}
SETS 
  /* ... */
  MORTALITY = { mortal, immortal };
  ALIGNMENT = { neutral, hero, villan };
  POWER = { enhanced, mutant, magic, cosmic };
  SPECIES = { human, alien, titan, android }
FREETYPES
  POWERS = NONE, SOME(POWER)
DEFINITIONS
  CHARACTER_STATE == 
    struct(alignment: ALIGNMENT, mortality: MORTALITY, powers: POWERS, 
      species: SPECIES, lives: 0..3, maxLives: 1..3, status: LIVING_STATUS);
\end{verbatim}

\hspace{-0.64cm} With the new attributes defined, we need to update the corresponding invariants. This also requires us to update the preconditions for the AddCharacterToTimeline operation to ensure we cannot add a character state that violates the invariants we just changed.

\begin{verbatim}
INVARIANT
  /* ... */
  !(s).(s: ran(characterStates) & s'powers = NONE => s'maxLives = 1)
  &
  !(s).(s: ran(characterStates) & s'mortality = immortal 
      => (s'maxLives, s'lives, s'status) = (1, 1, alive))
\end{verbatim}

\begin{verbatim}
AddCharacterToTimeline(m, t, c, s) =
  PRE
    /* ... */
    (s'powers /= NONE => s'maxLives = 1)
    &
    (s'mortality = immortal => (s'maxLives, s'lives, s'status) = (1, 1, alive))
\end{verbatim}

\hspace{-0.64cm} Replicating the GainPowers and GiveUpImmortality operators in B is similar to what we did in Z. The Preconditions are updated, and the new inputs of alignment and power for GainPowers helps express new states in the model.
\begin{verbatim}
KillCharacter(c, t) =
  PRE
    t: TIMELINE 
    &
    c: CHARACTER
    &
    (t,c): dom(characterStates)
    &
    characterStates((t,c))'status = alive
    &
    characterStates((t, c))'mortality = mortal
  THEN
    LET s BE s = characterStates(t,c) IN 
      characterStates(t,c) := 
        rec(alignment: s'alignment, mortality: s'mortality, powers: s'powers, 
          species: s'species, lives: s'lives - 1, maxLives: s'maxLives, status: dead)
    END
  END;
\end{verbatim}
\begin{verbatim}
ResurrectCharacter(t, c) =
  PRE
    t: TIMELINE 
    &
    c: CHARACTER
    &
    (t,c): dom(characterStates)
    &
    characterStates((t,c))'status = dead
    &
    characterStates((t,c))'lives > 0
  THEN
    LET s BE s = characterStates(t,c) IN 
      characterStates(t,c) := 
        rec(alignment: s'alignment, mortality: s'mortality, powers: s'powers, 
          species: s'species, lives: s'lives, maxLives: s'maxLives, status: alive)
    END
  END;
\end{verbatim}
\pagebreak
\begin{verbatim}
  GainPowers(t,c,l,p,a) =
    PRE
      t: TIMELINE 
      &
      c: CHARACTER
      &
      l: 2..3
      &
      p: POWER
      &
      a: ALIGNMENT
      &
      (t,c): dom(characterStates)
      &
      characterStates((t,c))'powers = NONE
      & 
      characterStates((t,c))'status = alive
    THEN
      LET s BE s = characterStates(t,c) IN
        characterStates(t,c) := 
          rec(alignment: a, mortality: s'mortality, powers: SOME(p), 
            species: s'species, lives: l, maxLives: l, status: alive)
      END
    END;

  GiveUpImmortality(t,c) =
    PRE
      t: TIMELINE 
      &
      c: CHARACTER
      &
      (t,c): dom(characterStates)
      &
      characterStates((t,c))'mortality = immortal
    THEN
      LET s BE s = characterStates(t,c) IN
        characterStates(t,c) := 
          rec(alignment: s'alignment, mortality: s'mortality, powers: s'powers, 
            species: s'species, lives: 1, maxLives: 1, status: alive)
      END
    END;
\end{verbatim}

\hspace{-0.7cm} That completes the extension for both models. Both can now express various character states through the new attributes, allowing a character’s allegiance, mortality, powers, or species to change across timelines. This provides a richer model that allows new combinations and permutations of its characters.

\pagebreak
\section*{Q2}

\subsection*{Introduction}

Software systems can be complex and often have a scope too large for any developer to comprehend fully. State-based modelling is a powerful technique that can help bring order to complexity through description, refinement, and proof, establishing a system's properties and behaviours. \\
\newline
To illustrate the benefits and limitations of state-based modelling in general and the relationship between Z and B, a basic trading system model has been designed to capture and store securities lending trades. These are transactions between parties who wish to borrow or loan a given security in return for a nominal fee and are a critical underpinning of the financial system. \\
\newline
By leveraging this model and providing additional support through referenced case studies and papers, we aim to illustrate the benefits and limitations of state-based modelling. Furthermore, by navigating from a Z to a B representation of our trading system, we aim to highlight their shared heritage and how their bespoke differences provide unique opportunities to be leveraged. 

\subsection*{State based modelling}

State-based modelling describes systems by defining their state, the constraints and guards that apply, and the transitions that states can undergo via operations. This results in a comprehensive and structured definition of the system’s model and associated behaviours, capabilities, and limitations. \\
\newline
By formally defining state, typically through mathematical notation, the aim is to remove ambiguities and systematically prove model correctness and consistency as it transitions through various states. Capturing and resolving errors in model definitions before implementation to help streamline the implementation's delivery and improve the system's safety. \\
\newline
Various options exist, with Z and B being popular formal methods in academia and industry. They share a common heritage, and both can be leveraged for writing formal specifications. We will use both to highlight the benefits and limitations of each method as well as the common attributes that apply to state-based modelling in general.

\subsection*{Z notation}
Z notation is a formal specification language based on set theory and first-order logic, designed to describe state and associated behaviours with mathematical precision. Initially conceived by Jean Raymond Abrial at the University of Grenoble, it was refined in collaboration with the Oxford University Computing Library and found use at IBM, Rolls-Royce, and British Aerospace. \\
\newline
At the heart of Z is the mathematical language that allows practitioners to work with sets, bags, sequences, types, functions, relations and logic that can then be collected and organised into schemas where declarations can be made with constraints. These schemas form the basis of how Z can be leveraged to describe the model of a system, not just from describing the state in the system, but how the system’s state can transition through schema operations. \\
\newline
Z is, however, not intended for the description and specification of nonfunctional properties such as usability, performance, security, efficiency, or reliability. It's designed to describe what, not how, implementation level details is not the domain of Z. Additional tools can be leveraged to fill that gap and complement the state-based modelling capabilities found in Z. 

\subsubsection*{Trading System Model}

The trading system model in Z starts with some helper types. An ‘Identifier’ type for use as a readable unique identifier for trades. A ‘Date’ type has also been introduced, represented as a natural number for easy comparisons. Finally, a ‘DateOption’ free type that allows us to express an end date for our trades in an optional manner. 

\begin{zed}
Identifier == Prefix \cross \{ d: \nat | d \geq 1 \land d \leq 9 \} \\ 
Date == \{ d: \nat | d \geq 20250101 \land d \leq 20991231 \} \\
DateOption ::= None | Some \ldata Date \rdata \\
\end{zed}

\hspace{-0.7cm} We have also defined the following free types: Security, Trader, and Counterparty, which represent the type of security being traded, the trader themselves, and the counterparty the trade is with for brevity. Direction, Status, and Prefix have been defined as they are suitable representations for the properties they will represent.

\begin{zed}
Counterparty ::= Citadel | Millennium  \\ 
Direction ::= Borrow | Loan \\
Security ::= Bond | Stock \\
Status ::= Open | Closed \\  
Trader ::= Joe | John | Jane | Joan \\
Prefix ::= T | S | U \\
\end{zed}

\hspace{-0.7cm} This now allows us to define our Trade schema, which will define our local state and capture the trade's identifier and associated properties. Our constraints have expressed a maximum quantity of 100,000, and we have added a guard to ensure the trade is marked as closed when an end date has been agreed.

\begin{schema}{Trade}
identifier: Identifier \\
direction: Direction \\ 
security: Security \\
quantity: \nat_1 \\
startDate: Date \\
endDate: DateOption \\ 
counterparty: Counterparty \\
status: Status \\
owner: Trader \\
\where
quantity \leq 100000 \\
endDate \neq None \implies status = Closed \\
\end{schema}
  
\hspace{-0.7cm} Trades are stored in the ‘TradingSystem’ schema, which keeps a record of all trades and users who can manage them. We introduce a sensible constraint that users cannot be removed from the system while they have Open trades, and we have provided a sensible initialisation.
\begin{schema}{TradingSystem}
trades: Identifier \pfun Trade \\
users: \finset Trader \\
\where
\forall t: \ran trades | t.status = Open @ t.owner \in users 
\end{schema}

\vspace{-0.2cm}

\begin{schema}{Init}
TradingSystem \\
\where
trades = \emptyset \\
users = \emptyset \\
\end{schema}

\hspace{-0.7cm} This brings us to operations for creating and closing trades. Creating a trade is a global operation that enables open trades to be booked in the system. Closing a trade is a local operation that specifies a termination date for the trade.

\begin{schema}{CreateTrade}
\Delta TradingSystem \\
t?: Trade \\
\where 
(t?).identifier \notin \dom trades \\
(t?).owner \in users \\
(t?).status = Open \\ 
(t?).endDate = None \\
trades' = trades \cup \{ (t?).identifier \mapsto t? \} \\
users' = users \\
\end{schema}

\begin{schema}{CloseTradeLocal}
\Delta Trade \\
d?: Date \\ 
o?: Trader \\
\where
status = Open \\ 
startDate < d? \\
owner = o? \\
startDate' = startDate \\
identifier' = identifier \\
direction' = direction \\
counterparty' = counterparty \\
security' = security \\
quantity' = quantity \\
owner' =  owner \\
endDate' = Some(d?) \\ 
status' = Closed \\
\end{schema}

\hspace{-0.7cm} As closing a trade is a local operation, we must specify how local operations for a trade are promoted to the global state TradingSystem so we can define global versions of those operations. While we could have defined close trade as a global operation given the number of properties a trade has this approach helped with readability.

\begin{schema}{PromoteTrade}
\Delta TradingSystem \\
\Delta Trade \\
i?: Identifier \\
\where
(i?) \in \dom trades \\
\theta Trade = trades(i?) \\
trades' = trades \oplus \{ i? \mapsto \theta Trade' \} \\
users' = users \\
\end{schema}

\begin{zed}
GlobalCloseTrade \defs \exists \Delta Trade @ CloseTradeLocal \land PromoteTrade \\
\end{zed}

\vspace{0.2cm}
\hspace{-0.7cm} Finally, we have two operations that allow traders to be added to the system and removed. We provide constraints to make sure the user has not been added yet or does exist to be removed and let the constraint for ‘TradingSystem’ enforce the constraint on when a trader can be removed from the system. 

\begin{schema}{AddTrader}
\Delta TradingSystem \\
u?: Trader \\ 
\where
u? \notin users \\
users' = users \cup \{ u? \} \\
trades' = trades \\
\end{schema}

\begin{schema}{RemoveTrader}
\Delta TradingSystem \\
u?: Trader \\ 
\where
u? \in users \\
users' = users \setminus \{ u? \} \\
trades' = trades \\
\end{schema}

\hspace{-0.7cm} That completes our trading system model in Z. Schemas allow us to describe what a trade looks like and how it is captured in the trading system. Scheme operators allow us to express how the state can change at both a local and global level and the constraints that must hold for the trading system to be consistent and valid.

\pagebreak
\subsubsection*{B}

B is another formal method originally developed by Abrial, like Z, based on set theory and first-order logic. The method addresses the lack of support in Z for a systematic refinement process to transition to an implementable system. Leveraged as part of the B-Method, it saw industry adoption, notably at Alstom and Siemens for the design and specification of railway systems. \\
\newline
B has a lot in common with Z, partly because Abrial played a large role in developing both methods. But at the heart of B specifications are abstract machines, where the practitioner can define much of what we could define in Z through defining sets, constants, properties, variables, invariants, initialisation, and operations for a given abstract state machine. \\
\newline
Like Z, B lacks support for nonfunctional requirements despite being closer to an implementation-level description, which is its key strength. Built-in refinement processes and support for code generation B as part of the B-Method aims to provide users with a tool that can go from specification to executable code. 

\subsubsection*{Trading System Model}

Our trading system model in B starts with the machine definition because we need to express dates as an option. Our DateOption free type in Z must be declared a full free type in B rather than a set.

\begin{verbatim}
MACHINE TradingSystem
  FREETYPES
    DATEOPTION = None, Some(DATE)
  /* ... */
END
\end{verbatim}

\hspace{-0.7cm} The remaining free types are expressed as sets in our abstract state machine and mirror the definitions found in the Z representation of the trading system. The helper types 'IDENTIFIER' and 'DATE' are declared as definitions alongside Trade, which has been modelled as a record in our state machine.
\begin{verbatim}
SETS 
  COUNTERPARTY = { Citadel, Millennium };
  DIRECTION = { Borrow, Loan };
  SECURITY = { Bond, Stock };
  STATUS = { Open, Closed };
  TRADER = { Joe, John, Jane, Joan };
  PREFIX = { T, U, S, V }
DEFINITIONS
  DATE == 20250101..20991231;
  IDENTIFIER == PREFIX * (1..9);
  TRADE == struct(identifier: IDENTIFIER, direction: DIRECTION, security: SECURITY, 
    quantity: NAT1, counterparty: COUNTERPARTY, startDate: DATE, 
    endDate: DATEOPTION, status: STATUS, owner: TRADER)
\end{verbatim}

\hspace{-0.7cm} With the key types defined, we can now declare the state that will become part of our machine. Like our Z representation, we will need to store users and trades. Variables have been declared as such and provided with sensible initialisation.

\begin{verbatim}
VARIABLES
  trades, users
INITIALISATION
  trades := {}
  ||
  users := {}
\end{verbatim}
    
\hspace{-0.7cm} Our state has rules, for example, a maximum trade size that can be added through invariants. Uniquely, where previously in Z, we could split our constraints, here, our list of invariants in the machine needs to cover both our trade record and the state of the machine itself.
\begin{verbatim}
INVARIANT
  trades: IDENTIFIER +-> TRADE
  &
  users: POW(TRADER)    
  &
  !(t).(t: ran(trades) => t'quantity <= 100000)
  &
  !(t).(t: ran(trades) => t'endDate /= None => t'status = Closed)
  &
  !(t).(t: ran(trades) & t'status = Open => t'owner: users)
\end{verbatim}

\hspace{-0.68cm} This finally moves us onto operations, starting with adding and removing traders and then creating and closing trades. Here, preconditions need to be explicitly declared so as not to violate the invariants we declared, and unlike Z, we only need to declare what we’re changing.

\begin{verbatim}
OPERATIONS
  AddTrader(u) = 
    PRE
      u: TRADER
      &
      u/: users
    THEN
      users := users \/ {u}
    END;
  RemoveTrader(u) = 
    PRE
      u: TRADER
      &
      u:users
      &
      {t | t: ran(trades) & t'owner = u & t'status = Open } = {}
    THEN
      users := users - {u}
    END;
\end{verbatim}
\begin{verbatim}
  CreateTrade(t) =
    PRE
      t: TRADE
      &
      t'identifier /: dom(trades)
      &
      t'owner: users 
      &
      t'status = Open 
      &
      t'endDate = None 
      &
      t'quantity <= 100000
    THEN
      trades := trades \/ { t'identifier |-> t }
    END;
    CloseTrade(i, d, o) =
      PRE
        i: IDENTIFIER
        &
        d: DATE
        &
        o: TRADER
        &
        i: dom(trades)
        &
        trades(i)'startDate < d
        &
        trades(i)'status = Open
        &
        trades(i)'endDate = None
        &
        trades(i)'owner = o
      THEN
        LET t BE t = trades(i) IN
          trades(i) := rec(identifier: t'identifier, direction: t'direction, 
            security: t'security, quantity: t'quantity, startDate: t'startDate, 
            counterparty: t'counterparty, owner: t'owner, endDate: Some(d), status: Closed)
        END
    END 
END
\end{verbatim}

\hspace{-0.68cm} This completes our trading system model in B. The machine definition describes our global state, where we define records, sets, and a free type to add to the type system and declare the state we will store. Through operations, we can detail how the state evolves and ensure consistency by declaring invariants and adding appropriate preconditions to our operations.

\pagebreak
\subsection*{Benefits \& Limitations}

Through our models we can see numerous benefits and limitations of state-based modeling in general and in Z and B especially that lines up with other accounts from various case studies in industry and academia.\\
\newline
The precise nature of specifications written through mathematical notation and the benefit it brings is evident in our models. As (Barroca and McDermid, 1992) discusses there is a well-defined interpretation of mathematics leaving little ambiguity for interpreters of the specification. This can be seen in two cases in our model. The first is how trade status is derived in the models, due to the constraint imposed in Z and our invariant in B it's made clear it is derived from the end date of trade. 
\begin{zed}
status = Closed \implies endDate \neq None \\
\end{zed}

\begin{verbatim}
!(t).(t: ran(trades) => t'endDate /= None => t'status = Closed)
\end{verbatim}
  
\hspace{-0.68cm} We can also interpret that a trade that ends on or before the start date is an invalid data point in our model. Due to the preconditions on close trade in both models. Highlighting how mathematical notation provides an unambiguous statement of the model's intent.

\begin{schema}{CloseTradeLocal}
\Delta Trade \\
d?: Date \\ 
/* ... */ \\
\where  
startDate < d? \\
/* ... */ \\
\end{schema}

\begin{verbatim}
CloseTrade(i, d, o) =
  PRE
    /* ... */
    trades(i)'startDate < d
  /* ... */
END 
\end{verbatim}

\hspace{-0.68cm} But one of the biggest benefits can be found in the early detection of errors in the design. As (Houston and King, 1991) highlight as part of the CISM project at IBM we saw that benefit appear as part of our trading system model. Traders can only close their own trades in the model, but in the previous revision you could remove a trader while they still had open trades. Resulting in an undesired state, where open trades in the system could not be closed out. The models were amended so a trader could only be removed once all trades were marked as closed. Catching issues like this at a design stage is enormously beneficial. 

\begin{zed}
\forall t: \ran trades | t.status = Open @ t.owner \in users \\ 
\end{zed}

\begin{verbatim}
!(t).(t: ran(trades) & t'status = Open => t'owner: users)
\end{verbatim}

\pagebreak

\hspace{-0.68cm} But these advantages come at a cost. There is a learning curve for writing specifications with mathematical notation even though case studies differ on how step the curve is. (Mashkoor et al, 2018) references that even people with a PhD in computer science are often put off by a Z or B specification while amongst developers the picture is even worse whereas (Barden et all, 1991) claim that with minimal Z training and expert guidance picking up and writing specifications can be achieved for those with no background in formal methods. \\

\hspace{-0.68cm} Our trading model is simple, but it isn’t too far a leap to imagine the below set comprehensions that return the number of open trades per trader being difficult to decipher for newcomers to the field. 

\begin{zed}
\{o: users @ o \mapsto \# \{t: \ran trades | t.owner = o \land t.status = Open\}\}
\end{zed}

\begin{verbatim}
{o•o: users | o |-> card({ t|t: ran(trades) & t'owner=o & t'status = Open })}
\end{verbatim}

\pagebreak
\subsection*{Relationship between Z and B}

Z and B, as discussed previously, share a common origin in Abrial, who has played a significant role in developing both methods. As both share the same mathematical foundation, based on set theory and first-order predicate logic, many of the constructs are shared. Statements in one can be translated to the other, as is seen in our trading system model in both Z and B, where functions, quantification, free types, set operators and much more can be expressed in both methods. 
\begin{zed}
Identifier \pfun Trade \\
\forall t: \ran trades | t.status = Open @ t.owner \in users \\
Trader ::= Joe | John | Jane | Joan  \\
users' = users \setminus \{ u? \} \\
\end{zed}

\begin{verbatim}
IDENTIFIER +-> TRADE
!(t).(t: ran(trades) & t'status = Open => t'owner: users)
TRADER = { Joe, John, Jane, Joan }
users := users \/ {u}
\end{verbatim}

\hspace{-0.68cm} However, they do immediately diverge when it comes to structure definitions. Z uses schemas that combine declarations with predicates and express states and operations that can apply to that state. At the same time, B is built around machine definitions, which include state declarations, invariants, and operations in an encapsulated object.

\begin{schema}{State / Operation}
declaration \\
\where 
predicate \\
\end{schema}

\begin{verbatim}
MACHINE State
  VARIABLES
    /* ... */
  INVARIANT
    /* ... */
  OPERATIONS
    /* ... */
END
\end{verbatim}

\hspace{-0.68cm} This has knock on effects for other concepts that appear in both methods. Notably promotion that manifests in a different manner, promoting methods from other machine definitions versus explicitly defining operators that describe the linkage between local and global states. There are other subtler differences as well. In Z state invariants complement our explicit preconditions. However, in B, they need to be explicitly declared, or we risk violating the invariant. This can be seen with the remove trader operation in B which has the explicit precondition that only needs to be expressed as a constraint in the schema in Z.
\begin{schema}{TradingSystem}
trades: Identifier \pfun Trade \\
users: \power Trader \\
\where
\forall t: \ran trades | t.status = Open @ t.owner \in users \\ 
\end{schema}

\begin{verbatim}
RemoveTrader(u) = 
  PRE
    u: TRADER
    &
    u: users
    &
    {t | t: ran(trades) & t'owner = u & t'status = Open } = {}
  THEN
    users := users - {u}
  END;
\end{verbatim}

\hspace{-0.68cm}This divergence comes in part because B is an extension of Z with the stated aim of empowering users to be able to take specification to implementation through a step-by-step refinement process and enhanced tooling most notably proof and code generation. As such B sits at a lower level closer to code than Z notation is. \\
\newline 
\hspace{-0.68cm} Z is an excellent formal method for abstract modelling and producing specifications that focus on what, not how. B is a great tool for going from specification to implementation with step-by-step refinement and code generation. In many cases, it will be complementary to use both. Z to outline an initial design before being ported into a concrete B implementation that can be further refined in an iterative manner to produce an executable system.
\subsection*{Conclusions}

State based modelling is a powerful technique that enables users to describe and rationalise systems through formal descriptions. It typically involves clearly defining states, transitions, and constraints through mathematical notation to produce well-rounded and robust specifications. \\
\newline
Z and B both provide great ways to build state descriptions. Z is an excellent whiteboard tool that enables users to express stateful systems with mathematical precision and is supported by an ecosystem of tools. B builds on top of that heritage adding support for step-by-step refinement of models, code generation and many other features that enable users to go from a specification to an executable program. \\
\newline
There are clear limitations, a steep learning curve and the need for at least a cursory understanding of mathematical notation are clearly barriers to wider adoption in areas where the technique is not considered mandatory. Even with broader adoption, it still holds other limitations around how well formal methods can scale to large and complex systems, and how they will integrate with standard development practices that emphasise building without finalised requirements and designs. \\
\newline
Regardless, state-based modelling and the formal methods of Z and B are powerful tools for practitioners who wish to remove ambiguous elements from designs and produce robust specifications for refined and tested systems. While there are limits to how far those benefits will stretch and how they could be adopted by others, they remain a powerful asset to be leveraged in developing both simple and complex systems. 
\pagebreak

\subsection*{References}

(Barroca and McDermid, 1992)

Barroca, L.M. and McDermid, J.A., 1992. Formal methods: Use and relevance for the development of safety-critical systems. The Computer Journal, 35(6), pp.579-599.

Barden, R., Stepney, S. and Cooper, D. (1991). The use of Z. Workshops in computing, pp.99–124.


Mashkoor, A., Kossak, F. and Egyed, A. (2018). Evaluating the suitability of state-based formal methods for industrial deployment. Software: Practice and Experience, 48(12), pp.2350–2379.

Bicarregui, J.C., Clutterbuck, D.L., Finnie, G., Haughton, H., Lano, K., Lesan, H., Marsh, D.W.R.M., Matthews, B.M., Moulding, M.R., Newton, A.R. and Ritchie, B., 1997. Formal methods into practice: case studies in the application of the B method. IEE Proceedings-Software, 144(2), pp.119-133. \\
\newline
Bowen, J.P., 2016. The Z notation: whence the cause and whither the course?. In Engineering Trustworthy Software Systems: First International School, SETSS 2014, Chongqing, China, September 8-13, 2014. Tutorial Lectures (pp. 103-151). Cham: Springer International Publishing. \\
\newline
Butler, M., Körner, P., Krings, S., Lecomte, T., Leuschel, M., Mejia, L.F. and Voisin, L., 2020, August. The first twenty-five years of industrial use of the B-method. In International Conference on Formal Methods for Industrial Critical Systems (pp. 189-209). Cham: Springer International Publishing. \\
\newline
Houston, I. and King, S., 1991. CICS project report experiences and results from the use of Z in IBM. In VDM'91 Formal Software Development Methods: 4th International Symposium of VDM Europe Noordwijkerhout, The Netherlands, October 1991 Proceedings 4 (pp. 588-596). Springer Berlin Heidelberg. \\
\newline
Kaur, A., Gulati, S. and Singh, S., 2012, October. A comparative study of two formal specification languages: Z-notation \& B-method. In Proceedings of the second international conference on computational science, engineering and information technology (pp. 524-531). \\
\newline
Zafar, N.A., 2006, December. Modeling and formal specification of automated train control system using Z notation. In 2006 IEEE International Multitopic Conference (pp. 438-443). IEEE. \\

\end{document}
