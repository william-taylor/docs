\documentclass{article}

% Packages
\usepackage{fuzz}
\usepackage{geometry}
\usepackage{listings}

% Metadata
\title{SBM - Final Assignment}
\date{18th March 2025}
\author{Anonymous}

\begin{document}
\maketitle

\pagebreak 

% Question 1
\section*{Q1}

\subsection*{Part A}

The state model below makes multiple assumptions. As it was stated that a timeline can be associated with, at most, one multiverse, it has been assumed that timelines do not necessarily need to be linked to a multiverse when created but can be linked later. it has also been assumed that delete operations should clean up all associated states and not only be available when none exists. \\
\newline
The model introduces a timeline and character function through axiomatic definitions to circumvent ProZ's component selection limitations. We also define a single initialisation operation with no input arguments to meet ProZ's initialisation requirements. \\ 
\newline
Promotion was adopted for the model to split concerns between how we change character state and then record that in the global state increasing readability. Additional functions were also defined to help improve the readability of output operators when extracting a set of character state properties. \\
\newline
Finally, it was assumed that embellishing the types in the model, such as the multiverse, timeline, and character types, was not expected beyond the scope of what was laid out in the scenario to keep the model terse.

\begin{zed}
[Multiverse, Timeline, Character] \\
LivingStatus ::= dead | alive \\
BeingType ::= human | immortal | superhero \\
CharacterLocation == Timeline \cross Character \\
\end{zed}

\begin{axdef}
timeline: CharacterLocation \fun Timeline \\
\where
\forall x: Timeline; y: Character @ \\
\t1 timeline(x, y) = x \\
\end{axdef}

\begin{axdef}
character: CharacterLocation \fun Character \\
\where
\forall x: Timeline; y: Character @ \\
\t1 character(x, y) = y \\
\end{axdef} 

\begin{schema}{CharacterState}
being: BeingType \\
status: LivingStatus \\
lives: 0 \upto 3  \\ 
maxLives: 1 \upto 3 \\ 
\where
being = immortal \implies (maxLives, lives, status) = (1, 1, alive) \\
being = human \implies maxLives = 1 \\
lives \leq maxLives \\ 
\end{schema}

\begin{schema}{Megaverse}
multiverses: \power Multiverse \\
characters: \power Character \\
timelines: \power Timeline \\ 
multiverseTimelines: Multiverse \rel Timeline \\
characterStates: CharacterLocation \pfun CharacterState \\
\where
\dom multiverseTimelines \subseteq multiverses \\ 
\ran multiverseTimelines \subseteq timelines \\ 
\forall t: timelines @ \#\{ m: multiverses | (m, t) \in multiverseTimelines \} \leq 1 \\
\{ p: \dom characterStates @ timeline(p) \} \subseteq timelines \\
\{ p: \dom characterStates @ character(p) \} \subseteq characters \\
\end{schema}

\begin{schema}{Init}
Megaverse \\ 
\where
multiverses = \emptyset \\
characters = \emptyset \\ 
timelines = \emptyset \\
multiverseTimelines = \emptyset \\
characterStates = \emptyset \\
\end{schema}

\begin{schema}{CreateMultiverse}
\Delta Megaverse \\
m?: Multiverse \\
\where
m? \notin multiverses \\
characters' = characters \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
multiverses' = multiverses \cup \{ m? \} \\ 
characterStates' = characterStates \\
\end{schema}

\begin{schema}{ResetMultiverse}
\Delta Megaverse \\
m?: Multiverse \\
\where
m? \in multiverses \\
multiverseTimelines \limg \{ m? \} \rimg \neq \emptyset \\
characters' = characters \\
timelines' = timelines \setminus multiverseTimelines \limg \{ m? \} \rimg   \\
multiverses' = multiverses \\
multiverseTimelines' = \{ m? \} \ndres multiverseTimelines \\
characterStates' = \{ p: \dom characterStates | \\
\t1 timeline(p) \in multiverseTimelines \limg \{ m? \} \rimg 
  \} \ndres characterStates \\
\end{schema} 

\begin{schema}{DeleteMultiverse}
\Delta Megaverse \\
m?: Multiverse \\
\where
m? \in multiverses \\
characters' = characters \\
timelines' = timelines \setminus multiverseTimelines \limg \{ m? \} \rimg   \\
multiverses' = multiverses \setminus \{ m? \} \\
multiverseTimelines' = \{ m? \} \ndres multiverseTimelines \\
characterStates' = \{ p: \dom characterStates | timeline(p) \\
\t1 \in multiverseTimelines \limg \{ m? \} \rimg \} \ndres characterStates \\
\end{schema} 

\begin{schema}{CreateTimeline}
\Delta Megaverse \\
t?: Timeline \\
\where
t? \notin timelines \\ 
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\ 
timelines' = timelines \cup \{ t? \} \\
multiverseTimelines' = multiverseTimelines \\
characterStates' = characterStates \\
\end{schema}

\begin{schema}{AddTimelineToMultiverse}
\Delta Megaverse \\
t?: Timeline \\
m?: Multiverse \\
\where
(m?, t?) \notin multiverseTimelines \\ 
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \cup \{ m? \mapsto t? \} \\
characterStates' = characterStates \\
\end{schema}

\begin{schema}{RemoveTimelineFromMultiverse}
\Delta Megaverse \\
t?: Timeline \\
m?: Multiverse \\
\where
(m?, t?) \in multiverseTimelines \\ 
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \setminus \{ m? \mapsto t? \} \\
characterStates' = characterStates \\
\end{schema}

\begin{schema}{MoveTimeline}
\Delta Megaverse \\
t?: Timeline \\
s?: Multiverse \\
d?: Multiverse \\
\where
s? \neq d? \\
\{ s?, d? \} \subseteq multiverses \\
s? \mapsto t? \in multiverseTimelines \\
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = characterStates \\
timelines' = timelines \\ 
multiverseTimelines' = multiverseTimelines \setminus \{ s? \mapsto t? \} \cup \{ d? \mapsto t? \} \\
\end{schema}

\begin{schema}{ResetTimeline}
\Delta Megaverse \\
t?: Timeline \\
\where
t? \in timelines \\
\{ p: \dom characterStates | t? = timeline(p) \} \neq \emptyset \\
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = \{ p: \dom characterStates | timeline(p) = t? \} \ndres characterStates \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \nrres \{ t? \} \\
\end{schema}

\begin{schema}{DeleteTimeline}
\Delta Megaverse \\
t?: Timeline \\
\where
t? \in timelines \\
characters' = characters \\ 
multiverses' = multiverses \\
characterStates' = \{ p: \dom characterStates | timeline(p) = t? \} \ndres characterStates \\
timelines' = timelines \setminus \{ t? \} \\
multiverseTimelines' = multiverseTimelines \nrres \{ t? \} \\
\end{schema}

\begin{schema}{CreateCharacter}
\Delta Megaverse \\
c?: Character \\
\where 
c? \notin characters \\
characters' = characters \cup \{ c? \} \\
multiverses' = multiverses \\
characterStates' = characterStates \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{DeleteCharacter}
\Delta Megaverse \\
c?: Character \\
\where 
c? \in characters \\
characters' = characters \setminus \{ c? \} \\
multiverses' = multiverses \\
characterStates' = \{ p: \dom characterStates | character(p) = c? \} \ndres characterStates \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{AddCharacterToTimeline}
\Delta Megaverse \\
m?: Multiverse \\
t?: Timeline \\
c?: Character \\
s?: CharacterState \\ 
\where
c? \in characters \\
(s?).status = alive \\
(s?).lives \neq 0 \\
(m? \mapsto t?) \in multiverseTimelines \\
(t? \mapsto c?) \notin \dom characterStates  \\
multiverses' = multiverses \\
characters' = characters \\
characterStates' = characterStates \cup \{ (t? \mapsto c?) \mapsto s? \} \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{RemoveCharacterFromTimeline}
\Delta Megaverse \\
m?: Multiverse \\
t?: Timeline \\
c?: Character \\
\where
(m? \mapsto t?) \in multiverseTimelines \\
(t? \mapsto c?) \in \dom characterStates  \\
multiverses' = multiverses \\
characters' = characters \\
characterStates' = \{ (t? \mapsto c?) \} \ndres characterStates \\ 
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{schema}{KillCharacterLocal} 
\Delta CharacterState \\
\where
being \neq immortal \\
status = alive \\
lives' = lives - 1 \\
maxLives' = maxLives \\
status' = dead \\
being' = being \\
\end{schema}

\begin{schema}{ResurrectCharacterLocal}
\Delta CharacterState \\
\where
status = dead \\
lives > 0 \\
being = superhero \\
maxLives' = maxLives \\
lives' = lives \\
being' = being \\
status' = alive \\
\end{schema}

\begin{schema}{ChangeToHumanLocal}
\Delta CharacterState \\
\where
being = immortal \\
lives' = 1 \\
maxLives' = 1 \\
being' = human \\
status' = alive \\
\end{schema}

\begin{schema}{ChangeToSuperheroLocal}
\Delta CharacterState \\
l?: 2 \upto 3 \\
\where
status = alive \\
being = human \\
lives' = l? \\
maxLives' = l? \\
status' = status \\
being' = superhero \\
\end{schema}

\begin{schema}{PromoteCharacterState}
\Delta Megaverse \\
\Delta CharacterState \\
c?: Character \\
t?: Timeline \\ 
\where 
(t?, c?) \in \dom characterStates \\ 
\theta CharacterState = characterStates(t?, c?) \\
characterStates' = characterStates \oplus \{ (t?, c?) \mapsto \theta CharacterState' \}   \\
multiverses' = multiverses \\
characters' = characters \\
timelines' = timelines \\
multiverseTimelines' = multiverseTimelines \\
\end{schema}

\begin{zed}
GlobalKillCharacter \defs \\
\t1 \exists \Delta CharacterState @ KillCharacterLocal \land PromoteCharacterState \\ 
\end{zed}

\begin{zed}
GlobalResurrectCharacter \defs \\
\t1 \exists \Delta CharacterState @ ResurrectCharacterLocal \land PromoteCharacterState \\
\end{zed}

\begin{zed}
GlobalChangeToHuman \defs \\ 
\t1 \exists \Delta CharacterState @ ChangeToHumanLocal \land PromoteCharacterState \\
\end{zed}

\begin{zed}
GlobalChangeToSuperhero \defs \\
\t1 \exists \Delta CharacterState @ ChangeToSuperheroLocal \land PromoteCharacterState \\
\end{zed}
      
\begin{axdef}
beingAndStatus: CharacterState \fun BeingType \cross LivingStatus \\
\where
\forall state: CharacterState @ \\
\t1 beingAndStatus(state) = (state.being, state.status) \\
\end{axdef}

\begin{schema}{LivingStatusForCharactersInTimeline}
\Xi Megaverse \\
t?: Timeline \\ 
r!: \power (Character \cross LivingStatus) \\
\where 
t? \in timelines \\
r! = \{ c: characters | (t?, c) \in \dom characterStates @ \\
\t1 c \mapsto (characterStates(t?,c)).status
\} \\ 
\end{schema}

\begin{schema}{CharacterStatusAcrossAllTimelines}
\Xi Megaverse \\
c?: Character \\ 
r!: \power (Timeline \cross (BeingType \cross LivingStatus)) \\
\where 
c? \in characters \\
r! = \{ t: timelines | (t, c?) \in \dom characterStates @  \\
\t1 t \mapsto beingAndStatus(characterStates((t, c?)))   
\} \\ 
\end{schema}

\pagebreak
\subsection*{Part B}

\vspace{0.5cm}
\begin{verbatim}
MACHINE Megaverse
  SETS 
    MULTIVERSE;
    TIMELINE;
    CHARACTER;
    LIVING_STATUS = { dead, alive };
    BEING_TYPE = { human, immortal, superhero }
  DEFINITIONS
    CHARACTER_STATE == 
      struct(being: BEING_TYPE, status: LIVING_STATUS, lives: 0..3, maxLives: 1..3);
    	CHARACTER_LOCATION == TIMELINE * CHARACTER;
    	BEING_AND_STATUS(s) == (s'being, s'status) 
  VARIABLES
    multiverses, timelines, multiverseTimelines, characters, characterStates
  INVARIANT
    multiverses: POW(MULTIVERSE)
    &
    timelines: POW(TIMELINE)
    & 
    characters: POW(CHARACTER)
    &
    multiverseTimelines: MULTIVERSE <-> TIMELINE
    &
    characterStates: CHARACTER_LOCATION +-> CHARACTER_STATE
    &
    dom(multiverseTimelines) <: multiverses
    &
    ran(multiverseTimelines) <: timelines
    &
    { p•p: dom(characterStates) | prj1(p) } <: timelines
    &
    { p•p: dom(characterStates) | prj2(p) } <: characters
    &
    !(s).(s: ran(characterStates) => s'lives <= s'maxLives)
    &
    !(s).(s: ran(characterStates) & s'being = human => s'maxLives = 1)
    &
    !(t).(t: timelines 
        => card({ m • m: multiverses & (m,t): multiverseTimelines | (m, t) }) <= 1)
    &
    !(s).(s: ran(characterStates) & s'being = immortal 
        => (s'maxLives, s'lives, s'status) = (1, 1, alive))
\end{verbatim}
\pagebreak
\begin{verbatim}
  INITIALISATION
    multiverses := {}
    ||
    timelines := {}
    ||
    characters := {}
    ||
    multiverseTimelines := {}
    ||
    characterStates := {}
  OPERATIONS
    CreateMultiverse(m) =
      PRE
        m: MULTIVERSE 
        &
        m/: multiverses
      THEN
        multiverses := multiverses \/ { m }
      END;
    ResetMultiverse(m) =
      PRE
        m: MULTIVERSE 
        &
        m: multiverses
        &
        multiverseTimelines[{ m }] /= {}
      THEN
        timelines := timelines \ multiverseTimelines[{ m }];
        characterStates := { p|p: dom(characterStates) & prj1(p): multiverseTimelines[{ m }] } 
          <<| characterStates; 
        multiverseTimelines := { m } <<| multiverseTimelines
      END;
    DeleteMultiverse(m) =
      PRE
        m: MULTIVERSE
        &
        m: multiverses
      THEN
        multiverses := multiverses \ { m };
        timelines := timelines \ multiverseTimelines[{ m }];
        characterStates := { p|p: dom(characterStates) & prj1(p): multiverseTimelines[{ m }] } 
          <<| characterStates; 
        multiverseTimelines := { m } <<| multiverseTimelines
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    CreateTimeline(t) =
      PRE
        t: TIMELINE
        &
        t/: timelines
      THEN
        timelines := timelines \/ { t }
      END;
    ResetTimeline(t) =
      PRE
        t: TIMELINE
        &
        t: timelines
        &
        { p|p: dom(characterStates) & t = prj1(p) } /= {}
      THEN
        multiverseTimelines := multiverseTimelines |>> { t }; 
        characterStates := { p|p: dom(characterStates) & prj1(p) = t } <<| characterStates 
      END;
    DeleteTimeline(t) =
      PRE
        t: TIMELINE
        &
        t: timelines
      THEN
        multiverseTimelines := multiverseTimelines |>> { t }; 
        timelines := timelines \ { t };
        characterStates := { p|p: dom(characterStates) & prj1(p) = t } <<| characterStates
      END;
    AddTimelineToMultiverse(t, m) =
      PRE
        t: TIMELINE
        &
        m: MULTIVERSE
        &
        t: timelines
        &
        m: multiverses
        &
        t /: ran(multiverseTimelines)
      THEN
        multiverseTimelines := multiverseTimelines \/ { m |-> t }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    RemoveTimelineFromMultiverse(t, m) =
      PRE
        t: TIMELINE
        &
        m: MULTIVERSE
        &
        t: timelines
        &
        m: multiverses
        &
        m |-> t : multiverseTimelines
      THEN
        multiverseTimelines := multiverseTimelines \ { m |-> t }
      END;
    MoveTimeline(t, s, d) =
      PRE
        t: TIMELINE
        & 
        s: MULTIVERSE
        &
        d: MULTIVERSE
        &
        t: timelines
        &
        s /= d
        &
        s |-> t : multiverseTimelines
        &
        {s, d} <: multiverses
      THEN
        multiverseTimelines := multiverseTimelines \ { s |-> t } \/ { d |-> t }
      END;
    CreateCharacter(c) =
      PRE
        c: CHARACTER 
        &
        c/: characters
      THEN
        characters := characters \/ { c }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    DeleteCharacter(c) =
      PRE
        c: CHARACTER
        &
        c: characters
      THEN
        characters := characters \ { c };
        characterStates := { p•p: dom(characterStates) & prj2(p) = c | (prj1(p), c) } 
          <<| characterStates 
      END;
    AddCharacterToTimeline(m, t, c, s) =
      PRE
        m: MULTIVERSE
        &
        t: TIMELINE
        &
        c: CHARACTER
        &
        s: CHARACTER_STATE
        &
        c: characters
        &
        s'status = alive
        & 
        s'lives /= 0 
        &
        s'lives <= s'maxLives
        &
        (m |-> t): multiverseTimelines  
        &
        (t |-> c)/: dom(characterStates)
        &
        (s'being = human => s'maxLives = 1)
        &
        (s'being = immortal => (s'maxLives, s'lives, s'status) = (1, 1, alive))
      THEN
        characterStates := characterStates \/ { (t |-> c) |-> s }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    RemoveCharacterFromTimeline(m, t, c) =
      PRE
        m: MULTIVERSE
        &
        t: TIMELINE
        &
        c: CHARACTER 
        &
        (m |-> t): multiverseTimelines
        &
        (t |-> c): dom(characterStates)
      THEN
        characterStates := { t |-> c } <<| characterStates
      END;
    ChangeToHuman(t,c) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'being = immortal
      THEN
        characterStates(t,c) := rec(being: human, status: alive, lives: 1, maxLives: 1)
      END;
    ChangeToSuperhero(t,c,l) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        l: 2..3
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'being = human
        & 
        characterStates((t,c))'status = alive
      THEN
        characterStates(t,c) := rec(being: superhero, status: alive, lives: l, maxLives: l)
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    KillCharacter(c, t) =
      PRE
        t: TIMELINE 
        &
        c: CHARACTER
        &
        (t,c): dom(characterStates)
        &
        characterStates((t,c))'status = alive
        &
        characterStates((t, c))'being: { human, superhero }
      THEN
        LET s BE s = characterStates(t,c) IN 
          characterStates(t,c) := 
            rec(being: s'being, status: dead, lives: s'lives - 1, maxLives: s'maxLives)
        END
      END;
  ResurrectCharacter(t, c) =
    PRE
      t: TIMELINE 
      &
      c: CHARACTER
      &
      (t,c): dom(characterStates)
      &
      characterStates((t,c))'status = dead
      &
      characterStates((t,c))'lives > 0
    THEN
      LET s BE s = characterStates(t,c) IN 
        characterStates(t,c) :=
          rec(being: s'being, status: alive, lives: s'lives, maxLives: s'maxLives)
      END
    END;
    r <-- LivingStatusForCharactersInTimeline(t) = 
      PRE
        t: TIMELINE
        &
        t: timelines
        &
        r: POW(CHARACTER * LIVING_STATUS)
      THEN 
        r := { c•c: characters & (t,c): dom(characterStates) | 
          c |-> characterStates(t, c)'status }
      END;
\end{verbatim}
\pagebreak
\begin{verbatim}
    r <-- CharacterStatusAcrossAllTimelines(c) =
      PRE
        c: CHARACTER
        &
        c: characters
        &
        r: POW(TIMELINE * (BEING_TYPE * LIVING_STATUS))
      THEN
        r := { t•t: timelines & (t,c): dom(characterStates) | 
          t |-> BEING_AND_STATUS(characterStates(t,c)) }
      END
END
\end{verbatim}
\pagebreak

\subsection*{Part C}

To extend the model, expanding the details we capture in the CharacterState schema to enable new states to be expressed is a logical extension of the model. We currently have a BeingType free type, but it is overloaded and expresses multiple things together, which is somewhat limiting. What if we wanted a non-human character to be capable of being a superhero? How might we represent a character with powers but may be a villain in the story? For this, additional free types have been created below. 

\begin{zed}
Mortality ::= mortal | immortal \\
Alignment ::= neutral | hero | villan \\
Power ::= enhanced | mutant | magic | cosmic \\
Species ::= human | alien | titan | android \\
\end{zed}

\hspace{-0.68cm} Introducing the first of many state-based problems: If humans are classified in terms of species, how do we determine whether they have powers? We can solve this with another free type with a constructor that allows us to express whether the character does not have any powers or if they do what it is explicitly. 
\begin{zed}
Powers ::= none | some \ldata Power \rdata \\
\end{zed}

\hspace{-0.68cm} As these are related to a character's state and not their core definition, we add these properties to the CharacterState schema, which has knock-on effects. Requiring updates to the constraints to point them at the new morality and powers attributes instead of the existing beingType attribute.

\begin{schema}{CharacterState}
alignment: Alignment \\
mortality: Mortality \\
powers: Powers \\
species: Species \\
lives: 0 \upto 3  \\ 
maxLives: 1 \upto 3 \\ 
status: LivingStatus \\
\where
mortality = immortal \implies (maxLives, lives, status) = (1, 1, alive) \\
powers = none \implies maxLives = 1 \\ 
lives \leq maxLives \\
\end{schema}

\hspace{-0.68cm} This introduces a new problem. ChangeToHuman and ChangeToSuperhero operations do not make much sense with these new attributes. Should alien immortals become human if they give up their immortality? Can only humans become superheroes? Redefining the operators as GainPowers and GiveUpImmortality made sense to resolve these restrictions and inconsistencies. This incorporates the new attributes to expand the possible states in the model. \\
\newline
The GainPowers operator now accepts alignment and power as inputs so they can be declared when a character gains superpowers. The GivingUpImmortality operation now updates the character's mortality status, leaving species untouched. Precondition updates were needed for all operations to move to the new attributes and for the body of each operation to state explicitly what happened to each new attribute.
\begin{schema}{KillCharacterLocal} 
\Delta CharacterState \\
\where
status = alive \\
mortality \neq immortal \\
alignment' = alignment \\
mortality' = mortality \\
powers' = powers \\ 
species' = species \\
lives' = lives - 1 \\
maxLives' = maxLives \\
status' = dead \\
\end{schema}

\begin{schema}{ResurrectCharacterLocal}
\Delta CharacterState \\
\where
lives > 0 \\
status = dead \\
powers \neq none \\ 
alignment' = alignment \\
mortality' = mortality \\
powers' = powers \\ 
species' = species \\
lives' = lives \\
maxLives' = maxLives \\
status' = alive \\
\end{schema}

\begin{schema}{GainPowersLocal}
\Delta CharacterState \\
p?: Power \\
a?: Alignment \\
l?: 2 \upto 3 \\
\where
status = alive \\ 
powers = none \\
alignment' = a? \\
mortality' = mortality \\
powers' = some(p?) \\ 
species' = species \\
lives' = l? \\
maxLives' = l? \\
status' = status \\
\end{schema}

\begin{schema}{GiveUpImmortalityLocal}
\Delta CharacterState \\
\where
mortality = immortal \\
alignment' = alignment \\
mortality' = mortal \\
powers' = powers \\ 
species' = species \\
lives' = 1 \\
maxLives' = 1 \\
status' = alive \\
\end{schema}

\hspace{-0.64cm} Finally, we need to define our new and updated operations in the context of the global state schema so that these local operations on CharacterState can be promoted to the Megaverse state schema.

\begin{zed}
GlobalGiveUpImmortality \defs \exists \Delta CharacterState @ GiveUpImmortalityLocal \land PromoteCharacterState \\
GlobalResurrectCharacter \defs \exists \Delta CharacterState @ ResurrectCharacterLocal \land PromoteCharacterState \\
GlobalKillCharacter \defs \exists \Delta CharacterState @ KillCharacterLocal \land PromoteCharacterState \\ 
GlobalGainPowers \defs \exists \Delta CharacterState @ GainPowersLocal \land PromoteCharacterState \\
\end{zed}

\hspace{-0.68cm} Adding these extensions to the B model starts with new sets for our new free type definitions. However, the Powers free type must be declared a full-free type in B as it cannot be expressed as a set. We can then add the new attributes to the CharacterState struct.

\begin{verbatim}
SETS 
  /* ... */
  MORTALITY = { mortal, immortal };
  ALIGNMENT = { neutral, hero, villan };
  POWER = { enhanced, mutant, magic, cosmic };
  SPECIES = { human, alien, titan, android }
FREETYPES
  POWERS = NONE, SOME(POWER)
DEFINITIONS
  CHARACTER_STATE == 
    struct(alignment: ALIGNMENT, mortality: MORTALITY, powers: POWERS, 
      species: SPECIES, lives: 0..3, maxLives: 1..3, status: LIVING_STATUS);
\end{verbatim}

\hspace{-0.64cm} With the new attributes defined, we need to update the corresponding invariants. This also requires us to update the preconditions for the AddCharacterToTimeline operation to ensure we cannot add a character state that violates the invariants we just changed.

\begin{verbatim}
INVARIANT
  /* ... */
  !(s).(s: ran(characterStates) & s'powers = NONE => s'maxLives = 1)
  &
  !(s).(s: ran(characterStates) & s'mortality = immortal 
      => (s'maxLives, s'lives, s'status) = (1, 1, alive))
\end{verbatim}

\begin{verbatim}
AddCharacterToTimeline(m, t, c, s) =
  PRE
    /* ... */
    (s'powers = NONE => s'maxLives = 1)
    &
    (s'mortality = immortal => (s'maxLives, s'lives, s'status) = (1, 1, alive))
\end{verbatim}

\hspace{-0.64cm} Replicating the GainPowers and GiveUpImmortality operators in B is similar to what we did in Z. The Preconditions are updated, and the new alignment and power inputs for GainPowers help express new states in the model.

\begin{verbatim}
KillCharacter(c, t) =
  PRE
    t: TIMELINE 
    &
    c: CHARACTER
    &
    (t,c): dom(characterStates)
    &
    characterStates((t,c))'status = alive
    &
    characterStates((t, c))'mortality = mortal
  THEN
    LET s BE s = characterStates(t,c) IN 
      characterStates(t,c) := 
        rec(alignment: s'alignment, mortality: s'mortality, powers: s'powers, 
          species: s'species, lives: s'lives - 1, maxLives: s'maxLives, status: dead)
    END
  END;
\end{verbatim}
\begin{verbatim}
ResurrectCharacter(t, c) =
  PRE
    t: TIMELINE 
    &
    c: CHARACTER
    &
    (t,c): dom(characterStates)
    &
    characterStates((t,c))'status = dead
    &
    characterStates((t,c))'lives > 0
  THEN
    LET s BE s = characterStates(t,c) IN 
      characterStates(t,c) := 
        rec(alignment: s'alignment, mortality: s'mortality, powers: s'powers, 
          species: s'species, lives: s'lives, maxLives: s'maxLives, status: alive)
    END
  END;
\end{verbatim}
\pagebreak
\begin{verbatim}
  GainPowers(t,c,l,p,a) =
    PRE
      t: TIMELINE 
      &
      c: CHARACTER
      &
      l: 2..3
      &
      p: POWER
      &
      a: ALIGNMENT
      &
      (t,c): dom(characterStates)
      &
      characterStates((t,c))'powers = NONE
      & 
      characterStates((t,c))'status = alive
    THEN
      LET s BE s = characterStates(t,c) IN
        characterStates(t,c) := 
          rec(alignment: a, mortality: s'mortality, powers: SOME(p), 
            species: s'species, lives: l, maxLives: l, status: alive)
      END
  END;

  GiveUpImmortality(t,c) =
    PRE
      t: TIMELINE 
      &
      c: CHARACTER
      &
      (t,c): dom(characterStates)
      &
      characterStates((t,c))'mortality = immortal
    THEN
      LET s BE s = characterStates(t,c) IN
        characterStates(t,c) := 
          rec(alignment: s'alignment, mortality: mortal, powers: s'powers, 
            species: s'species, lives: 1, maxLives: 1, status: alive)
      END
    END;
\end{verbatim}

\hspace{-0.7cm} That completes the extension for both models. Both can now express various character states through the new attributes, allowing a character’s allegiance, mortality, powers, or species to change across timelines. This provides a richer model that allows new combinations and permutations of its characters.

\pagebreak
\section*{Q2}

\subsection*{Introduction}

Software systems can be complex and often have a scope too large for any developer to comprehend fully. State-based modelling is a powerful technique that can help bring order to complexity through description, refinement, and proof, establishing a system's properties and behaviours. \\
\newline
To illustrate the benefits and limitations of state-based modelling in general and the relationship between Z and B, a basic trading system model has been designed to capture and store securities lending trades. These are transactions between parties wishing to borrow or loan a given security. \\
\newline
By leveraging this model and providing additional support through referenced case studies and papers, we aim to illustrate the benefits and limitations of state-based modelling, the Z and B formal methods and explain their unique relationship.

\subsection*{Trading System - Z}

\begin{zed}
Identifier == Prefix \cross \{ d: \nat | d \geq 1 \land d \leq 9 \} \\ 
Date == \{ d: \nat | d \geq 20250101 \land d \leq 20991231 \} \\
DateOption ::= None | Some \ldata Date \rdata \\
Counterparty ::= Citadel | Millennium  \\ 
Direction ::= Borrow | Loan \\
Security ::= Bond | Stock \\
Status ::= Open | Closed \\  
Trader ::= Joe | John | Jane | Joan \\
Prefix ::= T | S | U \\
\end{zed}
  
\vspace{-0.4cm} 

\begin{schema}{Trade}
identifier: Identifier \\
direction: Direction \\ 
security: Security \\
quantity: \nat_1 \\
startDate: Date \\
endDate: DateOption \\ 
counterparty: Counterparty \\
status: Status \\
owner: Trader \\
\where
quantity \leq 100000 \\
status = Closed \implies endDate \neq None \\
\end{schema}

\vspace{-0.4cm} 

\begin{schema}{TradingSystem}
trades: Identifier \pfun Trade \\
users: \power Trader \\
\where
\forall t: \ran trades | t.status = Open @ t.owner \in users \\ 
\end{schema}

\begin{schema}{Init}
TradingSystem \\
\where
trades = \emptyset \\
users = \emptyset \\
\end{schema}

\vspace{-0.4cm} 

\begin{schema}{CreateTrade}
\Delta TradingSystem \\
t?: Trade \\
\where 
(t?).identifier \notin \dom trades \\
(t?).owner \in users \\
(t?).status = Open \\ 
(t?).endDate = None \\
trades' = trades \cup \{ (t?).identifier \mapsto t? \} \\
users' = users \\
\end{schema}
  
\vspace{-0.4cm} 

\begin{schema}{CloseTradeLocal}
\Delta Trade \\
d?: Date \\ 
o?: Trader \\
\where
status = Open \\ 
startDate < d? \\
owner = o? \\
startDate' = startDate \\
identifier' = identifier \\
direction' = direction \\
counterparty' = counterparty \\
security' = security \\
quantity' = quantity \\
owner' =  owner \\
endDate' = Some(d?) \\ 
status' = Closed \\
\end{schema}

\vspace{-0.4cm} 

\begin{schema}{PromoteTrade}
\Delta TradingSystem \\
\Delta Trade \\
i?: Identifier \\
\where
(i?) \in \dom trades \\
\theta Trade = trades(i?) \\
trades' = trades \oplus \{ i? \mapsto \theta Trade' \} \\
users' = users \\
\end{schema}

\begin{zed}
GlobalCloseTrade \defs \exists \Delta Trade @ CloseTradeLocal \land PromoteTrade \\
\end{zed}

\vspace{-0.1cm} 

\begin{schema}{AddTrader}
\Delta TradingSystem \\
u?: Trader \\ 
\where
u? \notin users \\
users' = users \cup \{ u? \} \\
trades' = trades \\
\end{schema}

\vspace{-0.1cm} 

\begin{schema}{RemoveTrader}
\Delta TradingSystem \\
u?: Trader \\ 
\where
u? \in users \\
users' = users \setminus \{ u? \} \\
trades' = trades \\
\end{schema}

\vspace{-0.1cm} 

\begin{schema}{OpenTradeCountPerTrader}
\Xi TradingSystem \\
r!: \power (Trader \cross \nat) \\ 
\where
users \neq \emptyset \\
r! = \{ o: users @ o \mapsto \# \{ t: \ran trades | t.owner = o \land t.status = Open \} \} \\
\end{schema}

\subsection*{Trading System - B}

\begin{verbatim}
MACHINE TradingSystem
  FREETYPES
    DATEOPTION = None, Some(DATE)
  SETS 
    COUNTERPARTY = { Citadel, Millennium };
    DIRECTION = { Borrow, Loan };
    SECURITY = { Bond, Stock };
    STATUS = { Open, Closed };
    TRADER = { Joe, John, Jane, Joan };
    PREFIX = { T, U, S, V }
  DEFINITIONS
    DATE == 20250101..20991231;
    IDENTIFIER == PREFIX * (1..9);
    TRADE == struct(identifier: IDENTIFIER, direction: DIRECTION, security: SECURITY, 
	  quantity: NAT1, counterparty: COUNTERPARTY, startDate: DATE, 
          endDate: DATEOPTION, status: STATUS, owner: TRADER)
  VARIABLES
    trades, users
  INVARIANT
    trades: IDENTIFIER +-> TRADE
    &
    users: POW(TRADER)    
    &
    !(t).(t: ran(trades) => t'quantity <= 100000)
    &
    !(t).(t: ran(trades) => (t'endDate /= None => t'status = Closed))
    &
    !(t).(t: ran(trades) & t'status = Open => t'owner: users)
  INITIALISATION
    trades := {} 
    || 
    users := {}
  OPERATIONS
    AddTrader(u) = 
      PRE
        u: TRADER
        &
        u/: users
      THEN
        users := users \/ {u}
      END;
    RemoveTrader(u) = 
      PRE
        u: TRADER
        &
        u:users
        &
        {t | t: ran(trades) & t'owner = u & t'status = Open } = {}
      THEN
        users := users - {u}
      END;
    CreateTrade(t) =
      PRE
        t: TRADE
        &
        t'identifier /: dom(trades)
        &
        t'owner: users 
        &
        t'status = Open 
        &
        t'endDate = None 
        &
        t'quantity <= 100000
      THEN
        trades := trades \/ { t'identifier |-> t }
      END;


    CloseTrade(i, d, o) =
      PRE
        i: IDENTIFIER
        &
        d: DATE
        &
        o: TRADER
        &
        i: dom(trades)
        &
        trades(i)'startDate < d
        &
        trades(i)'status = Open
        &
        trades(i)'endDate = None
        &
        trades(i)'owner = o 
      THEN
        LET t BE t = trades(i) IN
          trades(i) := rec(
	    identifier: t'identifier, direction: t'direction, 
            security: t'security, quantity: t'quantity, startDate: t'startDate, 
            counterparty: t'counterparty, owner: t'owner, endDate: Some(d), status: Closed
          )
        END
      END; 
    r <-- OpenTradeCountPerTrader = 
      PRE
        users /= {} 
      THEN 
        r := { o•o: users | o |-> card({ t|t: ran(trades) & t'owner=o & t'status = Open }) }
      END
END
\end{verbatim}

\pagebreak
\subsection*{Benefits \& Limitations}

The general benefits of state-based modelling are well documented and can be seen from our trading system models. As Barroca and McDermid (1992) discuss there is a well-defined interpretation of mathematics leaving little ambiguity for interpreters of the specification, providing the end user with a precise description of the system's model. \\
\newline
This can be seen in two cases in our model. The first is how trade status is derived in the models, due to the constraint imposed in Z and our invariant in B it’s made clear it is derived from the end date of trade. We can also interpret that a trade that ends on or before the start date is an invalid trade in our model, due to the preconditions on close trade in both models. Highlighting how mathematical notation provides an unambiguous statement of the model's intent.
\begin{zed}
status = Closed \implies endDate \neq None \\
\end{zed}

\begin{verbatim}
!(t).(t: ran(trades) => t'endDate /= None => t'status = Closed)
\end{verbatim}
  
\vspace{-0.4cm}

\begin{schema}{CloseTradeLocal}
\Delta Trade \\
d?: Date \\ 
/* ... */ \\
\where  
startDate < d? \\
/* ... */ \\
\end{schema}

\begin{verbatim}
CloseTrade(i, d, o) =
  PRE
    /* ... */
    trades(i)'startDate < d
  THEN
    /* ... */
  END
END 
\end{verbatim}

\hspace{-0.68cm} However, one of the biggest benefits can be found in the early detection of errors in the design. As Houston and King (1991) highlight, as part of the CISM project at IBM, finding errors at the design stage rather than the implementation stage was enormously beneficial for the project. That same benefit appeared as we were developing the trading system model. \\
\newline
In the model, traders can only close their trades. However, one could remove a trader in a previous revision while still having open trades. This results in an undesired state where open trades in the system cannot be closed. The models were amended with a constraint in the Z model and a precondition and invariant in the B model, so a trader could only be removed from the trading system once all trades were marked as closed.

\begin{zed}
\forall t: \ran trades | t.status = Open @ t.owner \in users \\ 
\end{zed}

\begin{verbatim}
!(t).(t: ran(trades) & t'status = Open => t'owner: users)
\end{verbatim}
\pagebreak

\hspace{-0.68cm} However, these advantages come at a cost. There is a learning curve for writing specifications with mathematical notation, even though cases differ on how steep the curve is. Mashkoor et al, (2018) references that even people with a PhD in computer science are often put off by a Z or B specification, while the picture is even worse amongst developers. Whereas Barden et al. (1991) claims that with minimal Z training and expert guidance, picking up and writing specifications can be achieved for those with no background in formal methods. \\
\newline
\hspace{-0.68cm} This is reflected in our trading system model. If we extract the set comprehension present in the OpenTradeCountPerTrade output operator, which returns the number of open trades per trader, it is not difficult to imagine that newcomers to state-based modelling and formal methods would struggle to decipher the statements.

\begin{zed}
\{o: users @ o \mapsto \# \{t: \ran trades | t.owner = o \land t.status = Open\}\}
\end{zed}

\begin{verbatim}
{o•o: users | o |-> card({ t|t: ran(trades) & t'owner=o & t'status = Open })}
\end{verbatim}

Looking at Z specifically, it is a mature language that’s an ISO standard, and as Bowen (2016) stipulates, the reduction in research on the language will be partly due to its maturity. As we can see in our model, its constructs enable us to write expressive specifications, and as Barroca and McDermid (1992) point out, we are free to extend the language where we need to. With its use of schema and schema calculus, we can also tie smaller modules together to aid in modelling larger, more complex systems. \\
\newline
However, as Bowen (2016) notes, Z suffers from a less robust tooling ecosystem for other notations. The lack of appropriate tooling for proof is highlighted by Barden et al. (1991) as a key limiting factor. It is also important to remember that Z notation was designed with a specific purpose. As Woodcock and Davies (1996) explain, the notation is not for the description of nonfunctional properties such as performance, reliability or usability, where other supplementary formal methods would need to be adopted for such purposes. \\
\newline
Finally, looking at B, as Butler et al. (2020) write, B is among the formal methods of most significant industrial impact. Which Butlet et al. (2020) attribute to the strength of the tooling available for B. As Kaur et al. (2012) lists these capabilities out from model animation, deadlock detection, code and test generation, amongst other tooling supported for B, this highlights its biggest benefit. It enables users of B to gain confidence in their specifications while removing a lot of the manual work that would have been required had they developed their model using other methods. This was demonstrated when building the trading system model where model animation and interactively stepping through the various states helped highlight the issue with the previously mentioned remove trader operation. \\
\newline
There are gaps, however, as Bicarregui et al. (1997) discuss; for example, the code automatically generated from B required manual translation from the intermediate design outputted to the target language.

\pagebreak
\subsection*{Relationship between Z and B}

Z and B share a unique relationship partly due to their shared origin in Abrial, who has played a significant role in developing both methods. Both share the same mathematical foundation, based on set theory and first-order predicate logic. As a result, many of the constructs are shared, and statements in one can be translated to the other, as is seen in our trading system model in both Z and B, where functions, quantification, free types, set operators and much more can be expressed in both methods.
\begin{zed}
Identifier \pfun Trade \\
\forall t: \ran trades | t.status = Open @ t.owner \in users \\
Trader ::= Joe | John | Jane | Joan  \\
users' = users \setminus \{ u? \} \\
\end{zed}

\begin{verbatim}
IDENTIFIER +-> TRADE
!(t).(t: ran(trades) & t'status = Open => t'owner: users)
TRADER = { Joe, John, Jane, Joan }
users := users \/ {u}
\end{verbatim}

\hspace{-0.68cm} However, they do immediately diverge when it comes to structure definitions. Z uses schemas that combine declarations with predicates to express states and operations that can apply to them. Meanwhile, B is built around machine definitions, including variables, invariants, and operations, among others, in an encapsulated definition.

\begin{schema}{State / Operation}
declaration \\
\where 
predicate \\
\end{schema}

\begin{verbatim}
MACHINE State
  VARIABLES
    /* ... */
  INVARIANT
    /* ... */
  OPERATIONS
    /* ... */
END
\end{verbatim}

\hspace{-0.68cm} As a result, some shared concepts manifest in different ways. Notably, promotion where in B, one promotes to gain access to operations defined in other machines, whereas, in Z, we define explicit operators to describe the linkage between states. There are other subtler differences as well. In Z, state invariants complement our explicit preconditions but must be explicitly declared in B to avoid violating the invariant, as can be seen with the remove trader operation in B, which has the explicit precondition that only needs to be expressed as a constraint in Z.

\begin{schema}{TradingSystem}
trades: Identifier \pfun Trade \\
users: \power Trader \\
\where
\forall t: \ran trades | t.status = Open @ t.owner \in users \\ 
\end{schema}

\begin{verbatim}
RemoveTrader(u) = 
  PRE
    u: TRADER
    &
    u: users
    &
    {t | t: ran(trades) & t'owner = u & t'status = Open } = {}
  THEN
    users := users - {u}
  END;
\end{verbatim}

\hspace{-0.68cm} This divergence is largely because B was designed to be an industrial extension of Z. Empowering users with an approach that enables one to take a formal description from its initial specification to implementation through a step-by-step refinement process and enhanced tooling, such as model animation, proof, and code generation. As such, B sits closer to code than Z notation, which emphasises defining what rather than how. \\
\newline 
\hspace{-0.68cm} It, therefore, holds that Z is an excellent formal method for abstract modelling and producing specifications that focus on what, not how. B builds upon Z and enables users to build executable systems from refined specifications. In many cases, they are complementary methods, and it is advantageous to initially use Z to outline an initial design before being ported into a concrete B implementation so that the specification can be translated into an executable system.
\subsection*{Conclusions}

State based modelling is a powerful technique that enables users to describe and rationalise systems through formal descriptions. It typically involves clearly defining states, transitions, and constraints through mathematical notation to produce well-rounded and robust specifications. \\
\newline
Z and B provide great ways to build state descriptions and complement each other. Z is an excellent abstract modelling tool that enables users to express stateful systems with mathematical precision. B builds on that heritage, adding support for step-by-step refinement of models, code generation, and many other features that enable users to go from a specification to an executable program. \\
\newline
There are clear limitations; a learning curve based on the need for a cursory understanding of mathematical notation is a barrier to wider adoption in areas where the technique is not considered mandatory, such as safety critical systems. Even with broader adoption, it still holds limitations around how well formal methods can scale to larger, complex systems and how they integrate with standard development practices that emphasise building without finalised requirements and designs. \\
\newline
Regardless, state-based modelling and the formal methods of Z and B are potent tools for practitioners who wish to remove ambiguous elements from designs and produce robust specifications for systems. While there are limits to how far those benefits will stretch and how others could adopt them, they remain a powerful asset to be leveraged in developing simple and complex systems. 
\pagebreak

\subsection*{References}

Barden, R., Stepney, S. and Cooper, D. (1991). The use of Z. Workshops in computing, pp.99–124. \\
\newline
Barroca, L.M. and McDermid, J.A., 1992. Formal methods: Use and relevance for the development of safety-critical systems. The Computer Journal, 35(6), pp.579-599.
\newline
Bicarregui, J.C., Clutterbuck, D.L., Finnie, G., Haughton, H., Lano, K., Lesan, H., Marsh, D.W.R.M., Matthews, B.M., Moulding, M.R., Newton, A.R. and Ritchie, B., 1997. Formal methods into practice: case studies in the application of the B method. IEE Proceedings-Software, 144(2), pp.119-133. \\
\newline
Bowen, J.P., 2016. The Z notation: whence the cause and whither the course?. In Engineering Trustworthy Software Systems: First International School, SETSS 2014, Chongqing, China, September 8-13, 2014. Tutorial Lectures (pp. 103-151). Cham: Springer International Publishing. \\
\newline
Butler, M., Körner, P., Krings, S., Lecomte, T., Leuschel, M., Mejia, L.F. and Voisin, L., 2020, August. The first twenty-five years of industrial use of the B-method. In International Conference on Formal Methods for Industrial Critical Systems (pp. 189-209). Cham: Springer International Publishing. \\
\newline
Houston, I. and King, S., 1991. CICS project report experiences and results from the use of Z in IBM. In VDM'91 Formal Software Development Methods: 4th International Symposium of VDM Europe Noordwijkerhout, The Netherlands, October 1991 Proceedings 4 (pp. 588-596). Springer Berlin Heidelberg. \\
\newline
Kaur, A., Gulati, S. and Singh, S. (2012). A comparative study of two formal specification languages. Proceedings of the Second International Conference on Computational Science, Engineering and Information Technology - CCSEIT ’12. [online] doi:https://doi.org/10.1145/2393216.2393304. \\
\newline
Mashkoor, A., Kossak, F. and Egyed, A. (2018). Evaluating the suitability of state-based formal methods for industrial deployment. Software: Practice and Experience, 48(12), pp.2350–2379. \\
\newline
Woodcock, J. and Davies, J. (1996). Using Z. \\

\end{document}
